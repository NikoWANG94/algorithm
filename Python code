### 题目：
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。

>示例 1:
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

### 解析1：
两个数组拼接在一起，然后对数组进行排序，排序后返回中值。

时间：O((m+n)log(m+n))
空间：O(m+n)

步骤：
1. 对两个数组合并；
2. 对合并数组进行排序；
3. 返回中值


```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        num = nums1 + nums2
        num = sorted(num)
        length = len(num)
        if length%2 == 0:
            return (num[int(length/2)] + num[int(length/2)-1])/2
        else:
            return num[int((length-1)/2)]
```

### 解法2：
两个有序数组归并，归并后得到的新的有序数组，取中间元素。两个有序数组的合并复杂度是O(m+n)。和此算法类似，可以在归并排序的时候只判断是否是第k小的数（k为中值），无需将有序数组保存。算法不麻烦就不写了。

时间：O(m+n)
空间：O(m+n)

步骤：
1. 两个有序数组合并，归并算法：
   1. i，j两个指针分别遍历数组，直到遍历完某一个数组；
   2. 每一步遍历，选择两个数组中较小的一个，同时让对应的指针+1；
   3. 拼接剩余数组
2. 返回数组中位数

```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        num = []
        i,j = 0,0
        len1,len2 = len(nums1),len(nums2)
        while i<len1 and j < len2:
            if nums1[i] <= nums2[j]:
                num.append(nums1[i]) 
                i += 1
            else:
                num.append(nums2[j])
                j += 1
        # 拼接剩余的数组
        num.extend(nums1[i:] + nums2[j:])
        length = len1 + len2
        if length%2 == 0:
            return (num[int(length/2)] + num[int(length/2)-1])/2
        else:
            return num[int((length-1)/2)]
        
```
### 解析3：

上述的复杂度均不是log(m+n)，既然是log(m+n)，考虑到两个数组都是排序数组，尝试二分法解决。 求中位数其实就是求第k个数的特殊情况。 
假设我们的两个数组是A和B，A[1] ，A[2] ，A[3]，A[k/2] ... ，B[1]，B[2]，B[3]，B[k/2] ... ，如果 A[k/2]<B[k/2] ，那么A[1]，A[2]，A[3]...A[k/2]都不可能是第k小的数，可以直接去掉。作者在[详细通俗的思路分析，多解法](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2)中给出了详细的论证，非常棒的分享，同时给出了多种解法。

由此我们便可通过，每次去掉k/2个数来实现算法。如果有数组长度小于k/2，考虑数组最后一个元素即可。


### 题目：
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

>示例 1：
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

### 解析1：
暴力解法，遍历得到所有的子字符串，然后判断子字符串是否是回文的，直接超时。

时间：O(n^3)
空间：O(n)

```python
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        maxlen = 0
        res = ''
        for i in range(len(s)):
            for j in range(i, len(s)):
              temp_str = s[i:j+1]
              if self.IsPalin(temp_str) and maxlen < (j-i+1):
                res = temp_str
                maxlen = j-i
        return res

    def IsPalin(self, temp_str):
    # 判断一个字符串是否是回文
        return temp_str == temp_str[::-1]
```

### 解析2：
遍历字符串，以每一个字符为中心，然后往两边展开，找到最长的。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|944 ms|78.31%|
|空间|$O(n)$|13.7 MB|19.56%|

步骤：
1. 遍历字符串，以每一个字符为中心展开；
2. 求以这个字符为中心的最长回文子串；
   1. 以i为中心，即left和right均为i，向两边展开；
   2. 以i,i+1为中心，向两边展开，直到s[left]和s[right]不相等为止；
3. 比较两种情况较大的一个；


```python
class Solution(object):
    def longestPalindrome(self, s):
        res = ''
        for i in range(len(s)):
            temp_str = self.helper(i,i,s)
            if len(temp_str) > len(res):
                res = temp_str
                
            temp_str = self.helper(i, i+1, s)
            if len(temp_str) > len(res):
                res = temp_str
        return res
    

    def helper(self, left,right,s):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        # 此处需要注意，left和right为不相等的边界，需要进行范围缩减
        return s[left+1:right]
```

### 解析3：
动态规划，复杂度相同，但是时间要比上述算法长，但是相比
参考链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/

状态含义：dp[i][j] 子字符串s[i,j]是否是回文串，True和False
转移方程：dp[i][j] = s[i]==s[j] and (j-i<=2 or dp[i+1][j-1]):
* 如果字符串长度为1，则肯定是回文串；
* 如果子字符串长度为2，则判断s[i]和s[j]是否相等；
* 如果长度大于2，则判断s[i]和s[j]是否相等，以后dp[i+1][j-1]是否为True

需要注意的一点是赋值的先后顺序，动态规划依赖于前面的值，所以计算的时候需要保证前面被计算过。从转移方程可以看出，状态依赖于左下角的状态，所以按照从上到下，从左到右的顺序来进行赋值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|944 ms|78.31%|
|空间|$O(n)$|13.7 MB|19.56%|

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        size = len(s)

        dp = [[False for _ in range(size)] for _ in range(size)]

        longest_l = 0
        res = ''

        for r in range(size):
            for l in range(r+1):
                if s[l] == s[r] and (r - l <= 2 or dp[l + 1][r - 1]):
                    dp[l][r] = True
                    if r - l + 1 > longest_l:
                        longest_l = r - l + 1
                        res = s[l:r + 1]
        return res
```
### 题目：
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
```
示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
```

### 解析1：
直接翻转。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|78.46%|
|空间|$O(n)$|11.7 MB|23.69%|


```python
class Solution(object):
    def reverse(self, x):
        x = str(x)
        if x[0] == '-':
            res = int('-' + x[1:][::-1]) 
        
        else:
            res = int(x[::-1])
        print(res)
        return res if -1*2**31 <= res <= 2**31-1 else 0
```

### 题目：
请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:

输入: "42"
输出: 42

### 解析1：
题目不难，主要是各种边界条件，设置一个标志位，代表有效字符的开始，解决各种骚操作问题。

**边界条件：**
* 正或负号只能在第一个字符；
* 空格只能在有效字符开始之前；
* 超出取值范围的数；
* 各种标点符号；

```python
class Solution:
    def myAtoi(self, string):
        res = ''

        if not string:
            return 0
        flag = None
        begin =  False
        for char in string:
            if char == ' ' and not begin:
                continue
            elif char == '-' and not begin:
                flag = -1
                begin = True
            elif char == '+' and not begin:
                flag = 1
                begin = True
            elif not char.isdigit():
                break
            elif char.isdigit():
                res += char
                begin = True
                
        if not res:
            return 0
        if not flag:
            flag = 1
        res = int(''.join(res))*flag
        if res < -2**31:
            res = -2**31
        if res > 2**31 - 1:
            res = 2**31 - 1
        return res
```

### 解析2：
使用正则化，匹配字符串。
```python
class Solution:
    def myAtoi(self, s: str) -> int:
        return max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2**31 - 1), -2**31)
```

### 题目：
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
```
示例 1:

输入: 121
输出: true

示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

### 解析1：
转成字符串直接翻转，然后判断是否相等。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|48.46%|
|空间|$O(n)$|11.6 MB|33.69%|


```python
class Solution(object):
    def isPalindrome(self, x):
        x = str(x)
        return x == x[::-1]
```
### 题目：
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

### 解析1：
不会做，依次匹配，匹配'.'和‘*’。
```python
class Solution(object):
    def isMatch(self, text, pattern):
        if not pattern:
            return not text

        first_match = bool(text) and pattern[0] in {text[0], '.'}

        if len(pattern) >= 2 and pattern[1] == '*':
            return (self.isMatch(text, pattern[2:]) or
                    first_match and self.isMatch(text[1:], pattern))
        else:
            return first_match and self.isMatch(text[1:], pattern[1:])
```
### 题目：
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

### 解析1：
遍历两两元素组的集合，求每个间隔的大小。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(1)$| | |

```python
class Solution(object):
    def maxArea(self, height):
        res = 0
        length = len(height)
        for i in range(length-1):
            for j in range(i+1, length):
                temp = (j-i)*min(height[i], height[j])
                res = max(res, temp)
        return res
```


### 解析2：
双指针，设置两个指针分别从两端开始向里边凑。主要是左右指针移动的提交。对于左右两个边界，小的移动。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|136 ms|65.41%|
|空间|$O(1)$|13.1 MB |28.08% |

步骤：
1. 设置双指针，分别从0和len(height)-1开始遍历；
2. 比较面积的大小；
3. 如果左指针边界高度小于右指针高度：左指针移动，反之右指针移动。总之谁小谁移动。

```python
class Solution:
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        max_area,left,right = 0,0,len(height)-1
        while(left < right):
            max_area = max(max_area, (right-left)*min(height[left], height[right]))
            if height[left] < height[right]:left += 1
            else:right -= 1    
        return max_area
```
### 题目：
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
```
示例 1:

输入: "III"
输出: 3
示例 2:

输入: "IV"
输出: 4
```

### 解析1：
主要是发现一个规律，如果一个较小的数出现另一个前面，则减去这个数，其他依次保存相加即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|60 ms|96.68%|
|空间|$O(logn)$|13.9 MB|5.25%|

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000}

        return sum([-d[s[i]] if d[s[i]] < d[s[i+1]] else d[s[i]] for i in range(len(s)-1)] + [d[s[-1]]])
```
### 题目：
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

>示例 1:
输入: ["flower","flow","flight"]
输出: "fl"

### 解析1：垂直比较
每次都取各个字符串的同一列字符，如果完全相同那么set后长度为1。
求第一个不是0的位置，前面都是1，则代表都是相同的。

时间：最坏O(m*n)，n个长度为m完全一样的字符串；正常情况O(n * minLen)
空间：O(m)，为字符串的最大长度。

```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        # 将 str 中所有字符串并列到迭代器中，逐次并列返回 str 中所有字符串的第 1、2、3、…… 个字符
        num0 = [len(set(c))==1 for c in zip(*strs)] + [0]
        # index 搜索第一个 0 的位置
        return strs[0][:num0.index(0)] if strs else ''
```

### 解析2：水平比较
每个字符串两两比较，比如，第0和第1找最小公共前缀s1，再把s1和第2个比较，后面依次比较。

步骤：
1. 第一个字符作为最长公共前缀prefix；
2. prefix和后面字符依次比较，更新prefix；
   1. 判断prefix和字符的最长公共前缀，从头比较每一个字符，直到不相等位置，如果相等一直+1，
   2. 注意边界条件，主要是边界的处理；

时间：最坏O(m*n)，n个长度为m完全一样的字符串
空间：O(1)

```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        if strs == []:
            return ''

        prefix = strs[0]
        for i in range(1, len(strs)):
            length = min(len(prefix), len(strs[i]))
            j = 0
            while j < length:
                if prefix[j] != strs[i][j]:
                    break
                j += 1  
            prefix = prefix[:j]
        return prefix
```
### 题目：
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

### 解析1：
遍历三次，求和判断。超时。由于不可以包含重复的三元组，此处需要处理下，先排序，然后将三元组转成字符串，用set来保存，在转成list格式。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时| |
|空间|$O(1)$| | |

步骤：
1. 数组排序，建立一个set保存结果。
2. 三次循环，如果求和值等于0，转换成字符串保存在set中；
3. 转换数据格式，字符切分；


```python
class Solution(object):
    def threeSum(self, nums):
        length = len(nums)
        res = set()
        nums = sorted(nums)
        
        for i in range(length-2):
            for j in range(i+1, length-1):
                for k in range(j+1, length):
                    if nums[i] + nums[j] + nums[k] == 0:
                        res.add(" ".join([str(nums[i]),str(nums[j]),str(nums[k])]))
        res = [x.split(' ') for x in res]
        res = [[int(x) for x in l] for l in res]
        return res
```

### 解析2：
遍历一遍数组，然后第二层while循环遍历，双指针。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|732 ms|50.69%|
|空间|$O(1)$|14.8 MB|86.36%|


步骤：
1. 数组排序；
2. i循环遍历一遍数组：
   1. 如果nums[i]>0直接挑出，因为最小元素大于0，求和肯定大于0；
   2. 如果nums[i]==nums[i-1]，继续下一次循环；
   3. left,right双指针（i+1，length-1），不断计算求和；
      1. 如果求和=0：保存组合，更新left，right的值，直到nums[left] != nums[left-1]和nums[right]!= nums[right+1];
      2. 如果求和>0：left+1，左边界右移；
      3. 如果求和<0：right-1，右边界左移；

```python
class Solution(object):
    def threeSum(self, nums):
        res = []
        nums = sorted(nums)
        for i in range(len(nums)-2):
            if nums[i] > 0:break
            if nums[i] == nums[i-1] and i>0:continue
                
            left,right = i+1, len(nums)-1
            
            while left < right:
                temp = nums[i] + nums[left] + nums[right]
                if temp < 0:
                    left += 1
                elif temp > 0:
                    right -= 1
                    
                else:
                    res.append([nums[i],nums[left], nums[right]])
                    left += 1
                    right -= 1
                    
                    while left < right and nums[left] == nums[left-1]:left += 1
                    while left < right and nums[right] == nums[right+1]:right -= 1    
        return res
```

### 解析3：
这种方法非常快，以空间换时间的一种方案。三数之和是0一共可以分为多种情况：三个数都是0，一负一正一0，两负一正，两正一负，分开考虑。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|344ms|96.51%|
|空间|$O(n)$|15.4 MB|15.20%|

步骤:
1. 大于0，小于0，等于0分开存到三个数组里面；
2. 如果超过3个0存在则添加(0,0,0)答案；
3. 如果0的个数超过1个，判断是否存在一正一负一0的情况；
4. 判断两正一负和两负一正的情况是否存在；

```python
class Solution:
    def threeSum(self, nums):
        ans = set([])
        plus = sorted([n for n in nums if n>0])
        plus_c = set(plus)
        zero = [n for n in nums if n == 0]
        minus = sorted([n for n in nums if n<0])
        minus_c = set(minus)
        # all zero
        if len(zero)>2:
            ans.add((0,0,0))
        # plus zero minus
        if len(zero)>0:
            for n in minus:
                if -n in plus_c:
                    ans.add((n,0,-n))
        # plus minus minus
        n = len(minus)
        for i in range(n):
            for j in range(i+1,n):
                diff = -(minus[i]+minus[j])
                if diff in plus_c:
                    ans.add((minus[i],minus[j],diff))
        # plus plus minus
        n = len(plus)
        for i in range(n):
            for j in range(i+1,n):
                diff = -(plus[i]+plus[j])
                if diff in minus_c:
                    ans.add((diff,plus[i],plus[j]))
        return list(ans)
```

### 解析4：
采用字典保存每个数出现的索引，第一层循环，确定一个数后，后面类似2sum，主要解决重复问题。但是时间和空间都很爆炸。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|1588 ms|5.03%|
|空间|$O(n)$|15.3MB|16.42%|

```python
class Solution:
    def threeSum(self, nums):
        res = []
        nums.sort()
        
        for i in range(len(nums) - 1):
            if i > 0 and nums[i] == nums[i - 1]:continue
            if nums[i] > 0:break

            d = {}
            j = i + 1
            
            while j < len(nums):
                req = -nums[i] - nums[j]
                if req in d:
                    res.append([nums[i], req, nums[j]])
                    while j < len(nums) - 1 and nums[j] == nums[j + 1]:
                        j = j + 1
                else:
                    d[nums[j]] = j
                j += 1  
        return res
```
### 题目：
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
```
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```

### 解析1：
暴力解法，三轮遍历，然后超时了。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时||
|空间|$O(n)$|||

```python
class Solution(object):
    def threeSumClosest(self, nums, target):
        n = len(nums)
        if n < 3:
            return -1
        res = None
        diff = float('inf')
        for i in range(n-2):
            for j in range(i+1, n-1):
                for k in range(j+1, n):
                    temp_sum = nums[i]+nums[j]+nums[k]
                    if abs(temp_sum - target) < diff:
                        res = temp_sum
                        diff = abs(temp_sum - target)
        return res
```

### 解析2：
双指针法，首先进行排序，然后确定第一个数，后面两个数用双指针，分别进行移动，根绝temp的值，其实和3sum是一样的。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|76 ms|94.49%|
|空间|$O(n)$|11.7 MB|35.63%|

步骤：
1. 双指针法，对数组进行排序，遍历数组值，作为第一个数；
2. 双指针法，从i+1,n-1分别进行移动，根据sum和target的值；
3. 每次更新start和end值时，求sum和target的差距，更新最小值；

```python
class Solution(object):
    def threeSumClosest(self, nums, target):
        n = len(nums)
        if n < 3:return -1
        res = 0
        nums = sorted(nums)
        diff = float('inf')
        
        for i in range(n-2):
            start,end = i+1,n-1
            while start < end:
                temp = nums[i] + nums[start] + nums[end]
                if abs(temp - target) < diff:
                    diff = abs(temp - target)
                    res = temp
                if temp == target:
                    return temp
                elif temp < target:
                    start += 1
                elif temp > target:
                    end -= 1
        return res
```
### 题目：
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
示例:

输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

### 解析1：
循环，依次添加。假设遍历到第k位，字母组合为数组$f(k)$，第k+1位的时候，为$f(k)$的每个元素和第k+1位对应的字符一一拼接。每次更新$f(k)$而不是extend到原数组后面。

步骤：
1. 设置映射字典，如果字典value主动将字符串拆分成list；
2. 数组为空返回空；
3. 遍历数组i：
   1. 遍历res的每个元素，遍历当前字符对应字符串的每一个元素，添加到res的每一个元素里面；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间| |20 ms|85.53%|
|空间|$O(n)$|11.7 MB|28.79%|

```python
class Solution(object):
    def letterCombinations(self, digits):
    # 建立字典，'abc'主动拆分，显著提升速度啊
        kvmaps = {'2': ['a', 'b', 'c'],
                 '3': ['d', 'e', 'f'],
                 '4': ['g', 'h', 'i'],
                 '5': ['j', 'k', 'l'],
                 '6': ['m', 'n', 'o'],
                 '7': ['p', 'q', 'r', 's'],
                 '8': ['t', 'u', 'v'],
                 '9': ['w', 'x', 'y', 'z']}

        # 空字符要分开计算
        if not digits:return []
        res = ['']
        for num in digits:       
            res = [temp+char for temp in res for char in kvmaps[num]]
        return res
```

### 解析2：
回溯法，不断递归，遍历。注意模板，满足条件则保存，不满足条件，则遍历所有可选值，然后递归。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间| |16 ms|96.73%|
|空间|$O(n)$|11.8 MB|22.57%|

```python
class Solution(object):
    def letterCombinations(self, digits):
        kvmaps = {'2': ['a', 'b', 'c'],
         '3': ['d', 'e', 'f'],
         '4': ['g', 'h', 'i'],
         '5': ['j', 'k', 'l'],
         '6': ['m', 'n', 'o'],
         '7': ['p', 'q', 'r', 's'],
         '8': ['t', 'u', 'v'],
         '9': ['w', 'x', 'y', 'z']}
        
        if not digits:return []
        res = []
        def helper(digits, temp):
            if len(digits) == 0:res.append(temp)
            else:
                for char in kvmaps[digits[0]]:
                    helper(digits[1:], temp+char)   
        helper(digits, '')
        return res
```
### 题目：
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

>示例：
给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.

### 解析1：
利用双指针，第一个指针从哑结点先走n步，然后第二个指针从哑结点同步开始走。第一个指针到最后一个结点时，第二个到达倒数第k+1个。哑结点到设置哑结点，找到倒数k+1个结点，然后令倒数第k+1个结点的next值为后两个结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|28 ms|55.33%|
|空间|$O(n)$|11.7 MB|34.34%|

步骤：
1. 设置哑结点，dummy = ListNode(0),dummy.next = head
2. 双指针，第一个指针从0开始走n个，到达head的第n个结点；
3. 另一个指针从0开始和第一个指针同时开始走，如果第一指针到末尾，第二个指针正好到倒数第k+1个。

此题目未考虑边界条件，会出现越界的情况。
```python
class Solution(object):
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(-1)
        dummy.next = head
        fast = dummy
        while n:
            fast = fast.next
            n -= 1
        slow = dummy
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```

### 解析2：
先求结点个数L，然后去掉倒数第n个即正数第L-n+1个。遍历到第L-n个结点，然后跨过第l-n+1个结点。

步骤：
1. 求结点个数；
2. 从哑结点开始，遍历到第L-n个结点head；
3. head.next = head.next.next


```python
class Solution(object):
    def removeNthFromEnd(self, head, n):

        if not head:return
        L = 0
        dummy = ListNode(0)
        dummy.next = head
        head1 = dummy
        
        while head:
            head = head.next
            L += 1
        for _ in range(L-n):
            head1 = head1.next
        head1.next = head1.next.next
        
        return dummy.next
```

### 总结：
题目不麻烦，两个解法思路大同小异，主要是确定结点值的界限，和《剑指offer》找倒数第k个结点相似，这个是找到倒数第k+1个结点，然后跳过倒数第k个结点。需要注意边界条件，不过leetcode没有设置异常值。
### 题目：
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

>示例 1:
输入: "()"
输出: true

### 解析1：
建立一个栈保存每一个符号，如果新符号和栈顶元素是否可消去，通过字典对来实现。

步骤：
1. 建立一个字典对，来判断是否可以相消，{")": "(", "}": "{", "]": "["}；
2. 遍历每一个符号：
   1. 比较每一个符号在字典中值value和栈顶元素是否相等，如果相等则可以相消；
   2. 若可以消去，则栈顶出栈，否则添加新元素；
3. 判断栈是否为空，因为若是有效括号，所有符号会相消；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|20 ms|93.73%|
|空间|$O(1)$|11.8 MB|33.20%|

```python
class Solution(object):
    def isValid(self, s):
        s_dict = {')':'(','}':'{',"]":'['}
        stack = []
        for char in s:
            if stack and char in s_dict and s_dict[char] == stack[-1]:
                stack.pop()
            else:
                stack.append(char)
        return len(stack) == 0
```


### 题目：
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

>示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

### 解析1：
递归和并两个有序链表即可，类似归并的思想。通过循环也可以实现，判断是否到某一个链表的结点即可。递归注意终止条件，如果l1为空返回l2,如果l2为空返回l1。

步骤：
1. 终止条件；如果l1为空返回l2,如果l2为空返回l1；
2. 判断l1,l2的大小，将合并结点设置为较小的结点，然后递归调用函数；

k:链表个数，N:结点的总数目
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n+m)$|52 ms|5.41% |
|空间|$O(n+m)$|11.9 MB|12.83%|


```python
class Solution(object):
    def mergeTwoLists(self, l1, l2):
        if l1 == None:
            return l2
        if l2 == None:
            return l1
        # res = None
        if l1.val < l2.val:
            res = l1
            res.next = self.mergeTwoLists(l1.next, l2)
        else:
            res = l2
            res.next = self.mergeTwoLists(l1, l2.next)
        return res
```

### 解析2：
同样思路，但是速度快了很多。没有重新生成新的链表，直接通过控制返回递归来实现。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n+m)$|28 ms|77.55% |
|空间|$O(n+m)$|11.8 MB|24.75%|

```python
class Solution:
    def mergeTwoLists(self,l1, l2):
        if not l1:return l2
        if not l2:return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```


### 解析3：
循环实现，相比较递归实现，速度更快。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n+m)$|28 ms|77.55% |
|空间|$O(n+m)$|11.8 MB|24.75%|

步骤：
1. 设置哑结点；
2. 遍历l1，l2，每次选择较小的一个节点，直到任意一个为空，遍历时结点不断后移；
3. 判断l1，l2是否为空，然后连接不为空的结点。

```python
class Solution:
    def mergeTwoLists(self,l1, l2):   
        res = ListNode(-1)
        
        prev = res
        
        while l1 and l2:
            if l1.val < l2.val:
                prev.next = l1
                l1 = l1.next 
            else:
                prev.next = l2
                l2 = l2.next
            prev = prev.next
            
        prev.next = l1 if l1 else l2
        return res.next
```
### 总结：
《剑指offer》原题，没啥好说的。
### 题目：
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

>例如，给出 n = 3，生成结果为：
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

### 解析1：
暴力法，每个符号有两种可能一共有，所以复杂度是$O(2^{2N}*N)$。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(2^{2N}*N)$|200 ms|5.14%|
|空间|$O(2^{2N}*N)$|12.1 MB|14.04%|

步骤：
1. 回溯法生成可能的符号组成情况：
   1. 不断地做append和pop操作
2. 判断每个符号组合是否是有效的：
   1. 遍历每一个符号如果是"("，cnt+=1，否则cnt-=1，最后判断cnt的数量是否是0

```python
class Solution(object):
    def generateParenthesis(self, n):
        def generate(A = []):
        # 回溯法生成所有的可能情况；
            if len(A) == 2*n:
                if valid(A):
                    ans.append("".join(A))
            else:
                A.append('(')
                generate(A)
                A.pop()
                A.append(')')
                generate(A)
                A.pop()

        def valid(A):
        # 只用括号的话，判断是否是有效括号的方式，注意学会此函数，通过成对符号的删减来实现；
            bal = 0
            for c in A:
                if c == '(': bal += 1
                else: bal -= 1
                if bal < 0: return False
            return bal == 0

        ans = []
        generate()
        return ans
```

### 解析2：
回溯法生成有效符号，当符号有效的时候才添加新的符号。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|O($4^{N}/\sqrt N$)|32 ms|50.41%|
|空间|O($4^{N}/\sqrt N$)|12 MB|29.42%|

步骤：
1. 回溯生成，如果字符串长度等于2n，则有效；
2. 如果左括号的个数小于总个数（2n）的一般（n）则可以继续添加左括号，左括号数+1；
3. 如果右括号数小于左括号数，则可以继续添加右括号，右括号数+1；


```python
class Solution(object):
    def generateParenthesis(self, n):
        res = []
        def back(s='', left=0, right=0):
            if len(s) == 2*n:
                res.append(s)
            # 2*n个字符，小于一半
            if left < n:    
                back(s+'(', left+1, right)
            if right < left:
                back(s+')', left, right+1)
        back()
        return res
```
### 题目：
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

>示例:
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6

### 解析1：
遍历这k个链表，两两合并，超时了。应该采用归并的策略。

k:链表个数，N:结点的总数目
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(kN)$|超时| |
|空间|$O(n)$| | |


```python
class Solution(object):
    def mergeKLists(self, lists):
        def Merge2List(list1, list2):
        # 对两个有序链表进行排序
            if list1 == None:
                return list2
            if list2 == None:
                return list1
            res = None
            if list1.val < list2.val:
                res = list1
                res.next = Merge2List(list1.next, list2)
            else:
                res = list2
                res.next = Merge2List(list1, list2.next)
            return res
        
        length = len(lists)
        if length == 0: return 
        if length == 1: return lists[0]
        
        res = Merge2List(lists[0], lists[1])
        for i in range(2, length):
            res = Merge2List(res, lists[i])
        return res
```

### 解析2：
和上述方法类似，只是采用归并算法，同一层两两合并，然后再两两合并。但是时间依然很长。还不如遍历保存所有结点值，然后重新输出链表。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(klogN)$|236 ms|17.92%|
|空间|$O(n)$|24.3 MB|5.16%|

递归来实现归并：
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:return 
        n = len(lists)
        return self.merge(lists, 0, n-1)


    def merge(self,lists, left, right):
        if left == right:
            return lists[left]
        mid = left + (right - left) // 2
        l1 = self.merge(lists, left, mid)
        l2 = self.merge(lists, mid+1, right)
        return self.mergeTwoLists(l1, l2)


    def mergeTwoLists(self,l1, l2):
        if not l1:return l2
        if not l2:return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```


### 解析3：
首先想链表转成list，然后对list进行排序，排序后再将其转成排序后的链表。注意生成链表比较麻烦。

k:链表个数，N:结点的总数目
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(NlogN)$|88 ms|97.97%|
|空间|$O(N)$|20.1 MB|11.89%|

步骤：
1. 遍历K个链表，转成list，对数组进行排序；
2. 排序数组转变成链表；

```python
class Solution(object):
    def mergeKLists(self, lists):
        list1 = []
        for l in lists:
            while l:
                list1.append(l.val)
                l = l.next
        list1 = sorted(list1)
        
        res = head = ListNode(-1)
        for num in list1:
            head.next = ListNode(num)
            head = head.next
        return res.next
```
### 题目：
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
```
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

### 解析1：
双指针，一个在前面遍历，一个代表有多少个不重复的数。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|76 ms|94.49%|
|空间|$O(n)$|13.6 MB|25.63%|

```python
class Solution(object):
    def removeDuplicates(self, nums):
        res = 0
        for i in range(1,len(nums)):
            if nums[i] != nums[i-1]:
                res += 1
                nums[res] = nums[i]
        return res+1
```
### 题目：
实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
```
示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

### 解析1：
遍历，然后判断窗口元素是否和needle相同。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|40 ms|96.50%|
|空间|$O(1)$|14 MB|5.73%|

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n1,n2 = len(haystack),len(needle)
        for i in range(n1 - n2 + 1):
            if haystack[i:i+n2] == needle:
                return i
        return -1
```

### 解析2：
KMP算法实现，整个算法理解起来还是比较麻烦的。

```python
class Solution:
    def strStr(self, t, p):
        if not p : return 0
        _next = [0] * len(p)

        def getNext(p, _next):
            _next[0] = -1
            i = 0
            j = -1
            while i < len(p) - 1:
                if j == -1 or p[i] == p[j]:
                    i += 1
                    j += 1
                    _next[i] = j
                else:
                    j = _next[j]
        getNext(p, _next)
        i = 0
        j = 0
        while i < len(t) and j < len(p):
            if j == -1 or t[i] == p[j]:
                i += 1
                j += 1
            else:
                j = _next[j]
        if j == len(p):
            return i - j
        return -1
```
### 题目：
给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。
```
示例 1:

输入: dividend = 10, divisor = 3
输出: 3
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
```

### 解析1：
作弊玩法：

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        flag = 1 if dividend ^ divisor >= 0 else -1
        res = abs(dividend)//abs(divisor)
        res *= flag
        return min(max(-2**31, res), 2**31-1)
```

### 解析2：
被除数依次减去除数，但是次数太多的时候，会超时。

 
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        flag = 1 if dividend ^ divisor >= 0 else -1
        res = 0
        dividend,divisor = abs(dividend),abs(divisor)
        while dividend >= divisor:
            res += 1
            dividend -= divisor
            
        if flag < 0:res = -res
        if -2**31 <= res <= 2**31 - 1:return res
        else:return 2**31-1
```
### 题目：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1


### 解析1：

固定类型题目，记住算法：
1. 找出最大满足 nums[k] < nums[k+1]的索引，如果不存在，就翻转整个数组；
2. 找出另一个最大索引l满足 nums[l] > nums[k]；
3. 交换 nums[l] 和 nums[k]
4. 翻转 nums[k+1:]


|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|31.56%|
|空间|$O(1)$|13.7 MB|5.12%|


```python
class Solution:
    def nextPermutation(self, nums):
        firstIndex = -1
        n = len(nums)
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                firstIndex = i
                break
        #print(firstIndex)
        if firstIndex == -1:
            nums = nums[::-1]
            return 
        secondIndex = -1
        for i in range(n-1, firstIndex, -1):
            if nums[i] > nums[firstIndex]:
                secondIndex = i
                break
        nums[firstIndex],nums[secondIndex] = nums[secondIndex], nums[firstIndex]
        nums[firstIndex+1:] = nums[firstIndex+1:][::-1]
```
### 题目：
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

```
示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

### 解析1：
暴力法，生成所有子字符串，然后判断是否是有效括号。直接超时

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时| |
|空间|$O(n)$| | |

```python
class Solution(object):
    def longestValidParentheses(self, s):
        n = len(s)
        res = 0
        for i in range(n-1):
            for j in range(i, n):
                temp = s[i:j+1]
                if self.valid(temp):
                    res = max(res, j+1-i)
        return res
    
    def valid(self, s):
        res = 0
        for char in s:
            if char == '(':res += 1
            else:res -= 1
            if res < 0:return False
        return res == 0     
```

### 解析2：
动态规划。
状态含义:dp[i] 以i为结尾的最长有效括号长度；
状态转移方程： dp[i] = dp[i-2] + 2 if s[i] == ')' and s[i-1] == '('   
dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 if s[i] == ')' and s[i-1] == ')' and s[i-dp[i-1]-1] == '('

此处状态方程的推导比较麻烦：
1. 如果结尾是'...()':dp[i] =dp[i-2] + 2;
2. 如果结尾是'...))':假设倒数第二个括号对应的有效字符串是 $sub_s$,如果$sub_s$的前一个字符不是'('，dp[i]=dp[i-1]。如果$sub_s$前面是‘(’则构成有效字符。那么‘($sub_s$)’的长度为dp[i-1] + 2,然后再加上dp[i-2-dp[i-1]]。


|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|83%|
|空间|$O(n)$|12.3 MB| |


```python
class Solution(object):
    def longestValidParentheses(self, s):
        n = len(s)
        dp = [0] * n
        res = 0
        for i in range(1,n):
            if s[i] == ')':
                if s[i-1] == '(':
                    dp[i] = dp[i-2] + 2
                elif i-1-dp[i-1] >= 0 and s[i-1-dp[i-1]] == '(':
                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2]+2
            res = max(res, dp[i])
        return res
```

### 解析3：
使用栈，但是不是特别理解，还是有待消化。


```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        if not s:
            return 0
        res = 0
        stack = [-1]
        for i in range(len(s)):
            if s[i] == "(":
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res = max(res,i - stack[-1])
        return res
```
### 题目：
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

>示例 1:
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

### 解析1：
遍历数组。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|48 ms|21.59%|
|空间|$O(1)$|12.1 MB|5.1%|


```python
class Solution(object):
    def search(self, nums, target):
        for i in range(len(nums)):
            if nums[i] == target:
                return i
        return -1
```

### 






### 二分法：
根本思想是二分法，首先看一下典型的二分查找。对于一个有序数组，查找某个元素在数组中的位置，如果找不到返回-1。
```python
def binary_search(inp, item):
    left,right = 0,len(inp)
    while left <=right:
        mid = (left + right)//2
        if inp[mid] == item:
            return mid
        elif inp[mid] > item:
        # 如果不相等判断下一个值即可
            right = mid-1
        else:
            left = mid + 1
    return -1
```


### 题目：
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。
```
示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 解析1：
两次遍历，分别得到target的起始值和结束值。虽然复杂度是$O(n)$但是速度依然很快。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|88 ms|95.18%|
|空间|$O(1)$|13.4 MB|5.32%|

```python
class Solution(object):
    def searchRange(self, nums, target):
        res = [-1,-1]
        n = len(nums)
        for i in range(n):
            if nums[i] == target:
                res[0] = i
                break
        for i in reversed(range(n)):
            if nums[i] == target:
                res[1] = i
                break
        return res
```

### 解析2：
使用二分查找分别查找左右边界。二分查找的重点在细节。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|84 ms|98.49%|
|空间|$O(1)$|13 MB|34.18%|

```python
class Solution:
    # 查找左右边界，left控制左边界还是右边界
    def extreme_insertion_index(self, nums, target, left):
        lo = 0
        hi = len(nums)

        while lo < hi:
            mid = (lo + hi) // 2
            if nums[mid] > target or (left and target == nums[mid]):
                hi = mid
            else:
                lo = mid+1
        return lo


    def searchRange(self, nums, target):
        left_idx = self.extreme_insertion_index(nums, target, True)
        if left_idx == len(nums) or nums[left_idx] != target:
            return [-1, -1]

        return [left_idx, self.extreme_insertion_index(nums, target, False)-1]
```

### 解析3：
分开实现左边界和右边界，left=0,right=n-1初始化。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|80 ms|99.47%|
|空间|$O(1)$|12.9 MB|41.34%|

步骤：
1. 左边界查找：
   1. left=0,right=n-1初始化；
   2. 循环终止条件：left<=rigtht:
      1. 中间值等于目标值或者中间值大于目标值：right=mid-1，
      2. 中间值小于目标值：left = mid+1 


```python
class Solution(object):
    def searchRange(self, nums, target):
        return [self.left_bound(nums,target), self.right_bound(nums,target)]
    
    def left_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
        if left <= len(nums)-1 and nums[left] == target: return left  # 注意
        else: return -1   


    def right_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
        if right >= 0 and nums[right] == target: return right # 注意
        else: return -1
```
### 题目：
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
```
示例 1:

输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

### 解析1：
按照定义解决。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|112 ms|82.10%|
|空间|$O(1)$|13.8 MB|5.17%|

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for i in range(9):
            temp = set()
            for j in range(9):
                if board[i][j] in temp:return False
                if board[i][j].isdigit():temp.add(board[i][j])
                    
        for i in range(9):
            temp = set()
            for j in range(9):
                if board[j][i] in temp:return False
                if board[j][i].isdigit():temp.add(board[j][i])
        
        array1 = [(0,0),(0,3),(0,6),(3,0),(3,3),(3,6),(6,0),(6,3),(6,6)]
        flag = [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
        
        for i,j in array1:
            temp = set()
            for x,y in flag:
                n_x = i+x
                n_y = j+y

                if board[n_x][n_y] in temp:return False
                if board[n_x][n_y].isdigit():temp.add(board[n_x][n_y])
        return True
```
### 题目：
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。
 
```
示例 1:

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```

### 解析1：
学好DFS保全家，多刷题总结模板，刷习惯就好了。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O()$|60ms|67.20%|
|空间|$O(1)$|11.9 MB|12.97%|


步骤：
1. 对candidates进行排序，避免重复；
2. 回溯算法：
   1. 如果满足条件，输出结果；
   2. 遍历候选数组，相当于深度遍历一棵树，需要进行剪枝，如果不满足要求，提前剪除；
   3. 递归实现；


```python
class Solution(object):
    def combinationSum(self, candidates, target):
        res = []
        # 对候选数组进行排序，避免出现重复元素
        candidates = sorted(candidates)
        
        def backtrack(target, temp):
            if target == 0:
                res.append(temp)

            for num in candidates:
                if num > target:break
                if temp and num < temp[-1]:continue
                else:
                    backtrack(target-num, temp+[num])
        backtrack(target, [])
        return res
```

### 回溯总结：
1. https://leetcode-cn.com/circle/article/GV6eQ2/
2. https://www.cnblogs.com/wuyuegb2312/p/3273337.html
3. Leetcode 17.电话号码的字母组合
4. Leetcode 39.组合总和
5. Leetcode 40.组合总和II
6. Leetcode 46.全排列
7. Leetcode 47.全排列II
8. Leetcode 77.组合
9. Leetcode 78.子集
10. Leetcode 216.组合总和III


回溯模板：
```python

```
### 题目：
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 

```
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

### 解析1：
和39类似，需要对candidates进行选取。每次选取当前元素后面的进行回溯。但是判断是否相同剪枝的地方有些不同。如果候选数组中两个数相同的，则进行剪枝，避免重复。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O()$|60ms|60.89%|
|空间|$O(1)$|11.9 MB|12.14%|

```python
class Solution(object):
    def combinationSum2(self, candidates, target):
        res = []
        # 对候选数组进行排序，避免出现重复元素
        candidates = sorted(candidates)
        n = len(candidates)
        
        def backtrack(i, target, temp):
            if target == 0:
                res.append(temp)

            for j in range(i,n):
                num = candidates[j]
                # 剪枝，如果大于target，break
                if num > target:break
                if j>i and candidates[j] == candidates[j-1]:continue
                else:backtrack(j+1, target-num, temp+[num])

        backtrack(0, target, [])
        return res
```
### 题目：
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6

### 解析1：
每个点上面所能存储的水，由左右柱子的最大值决定，二者小的那个，然后减去当前柱子的高度。超时了。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(1)$| | |

步骤：
1. 遍历每一个柱子；
2. 求每个柱子左右边界柱子高度的最大值max_left, max_right；
3. 当前柱子上方所能存储的水，为max_left和max_right的较小值减去柱子的高度。


```python
class Solution(object):
    def trap(self, height):
        res = 0
        for i in range(len(height)):
            j = i
            max_left = 0
            while j >= 0:
                max_left = max(max_left, height[j])
                j -= 1
            max_right = 0
            for j in range(i, len(height)):
                max_right = max(max_right, height[j])
            res += min(max_left, max_right) - height[i]
        return res
```

### 解析2：
遍历数组，保存每个坐标i到最左边的最大值，以及到右边的最大值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|87.59%|
|空间|$O(1)$|13.1 MB |28.08% |

步骤：
1. 遍历数组保存每个点左边和右边的的最大值在新的数组中；
2. 再遍历一次数组，每个柱子储水为min(max_left,max_right)-柱子高度

```python
class Solution(object):
    def trap(self, height):
        length = len(height)
        if length < 2:
            return 0
        
        res = 0
        max_left,max_right = [0]*length, [0]*length
        max_left[0],max_right[-1] = height[0],height[-1]
        
        for i in range(1, length):
            max_left[i] = max(height[i], max_left[i-1])

        for i in range(length-2,-1,-1):
            max_right[i] = max(height[i], max_right[i+1])

        for i in range(length):
            res += min(max_left[i], max_right[i]) - height[i]
        return res
```

### 解析3：
栈来实现。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height: return 0
        n = len(height)
        stack = []
        res = 0
        for i in range(n):
            #print(stack)
            while stack and height[stack[-1]] < height[i]:
                tmp = stack.pop()
                if not stack: break
                res += (min(height[i], height[stack[-1]]) - height[tmp]) * (i-stack[-1] - 1)
            stack.append(i)
        return res
```

### 解析4：
双指针实现。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|99.72%|
|空间|$O(1)$|12 MB|47.99%|

```python
class Solution:
    def trap(self, height):
        if not height: return 0
        left = 0
        right = len(height) - 1
        res = 0
        # 记录左右边最大值
        left_max = height[left]
        right_max = height[right]
        while left < right:
        # 如果左边小于右边就看左边；
            if height[left] < height[right]:
            # 如果left_max大于height[left]，添加该位置的储水量
                if left_max > height[left]:
                    res += left_max - height[left]
                    # 否则替换left_max
                else:
                    left_max = height[left]
                left += 1
            else:
                if right_max > height[right]:
                    res += right_max - height[right]
                else:
                    right_max = height[right]
                right -= 1 
        return res
```
### 题目：
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
```
示例 1:

输入: num1 = "2", num2 = "3"
输出: "6"
```

### 解析1：
投机取巧系列。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|24 ms|89.49%|
|空间|$O(n)$|11.7 MB|37.63%|


```python
class Solution(object):
    def multiply(self, num1, num2):
        return str(int(num1)*int(num2))
```

字符串模拟竖式相乘。
### 题目：
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。
```
示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

### 解析1：
动态规划。

状态含义：dp[i]到达第i个点所需的最少步数；
状态方程：dp[i] = max(dp[i], dp[j]+1) for j in [0,i-1] if nums[j] >= i-j

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(n)$| | |

```python
class Solution(object):
    def jump(self, nums):
        n = len(nums)
        dp = [float('inf')] * n
        dp[0] = 0
        for i in range(1,n):
            for j in range(i):
                if nums[j] >= (i-j):
                    dp[i] = min(dp[i], dp[j]+1)
        return dp[n-1]
```

### 解析2：
贪心法，每次跳跃到最远的边界。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|172 ms|13.19%|
|空间|$O(n)$|13.5 MB|14.77%|

```python
class Solution:
    def jump(self, nums):
        n = len(nums)
        if n < 2:
            return 0

        # 跳跃计数，初始值为1
        jump_num = 1
        # 元素能够跳跃到的最大位置
        max_dist = nums[0]
        # 由max_dist得出跳跃的边界
        border = nums[0]
        for i in range(n - 1):
            # 遍历两个边界之间的元素，求出最大元素位置和最大跳跃数之和,产生新的边界
            max_dist = max(max_dist, i + nums[i])
            # 元素每次到达跳跃的边界，则重新更新边界，跳跃计数增加1
            if i == border:
                border = max_dist
                jump_num += 1

        return jump_num
```
### 题目：
给定一个没有重复数字的序列，返回其所有可能的全排列。

>示例:
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]


### 解析1：
直接使用python自带的工具来实现。使用`itertools.permutations`产生数组的额全排列。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||32 ms|76.07%|
|空间|$O(N!)$|11.7 MB|38.23%|


```python
import itertools
class Solution(object):
    def permute(self, nums):
        return list(itertools.permutations(nums))
```

### 解析2：
手动实现上述算法。主要便是回溯法，对于回溯的理解依然不够，需要做更多的题。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||68 ms|50.43%|
|空间|$O(N!)$|14.1 MB|5.27%|

步骤：
1. 建立一个res保存所有满足条件的排列；
2. 回溯算法：
   1. 结束条件：如果nums为空则结束；
   2. 选择：nums内的每一个数，进行选择，将回溯算法嵌套在for循环里面，去掉被循环的元素；

```python
class Solution(object):
    def permute(self, nums):
        res = []
        def backtrack(nums, temp):
            if len(nums) == 0:
                res.append(temp)
            for i in range(len(nums)):
                backtrack(nums[:i]+nums[i+1:], temp+[nums[i]])
        backtrack(nums, [])
        return res
```


### 题目：
给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例:

输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

### 解析1：
依然是回溯法，只不过每次在添加新排列的时候，判断是否在res中出现过。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||2188 ms|5%|
|空间|$O(N!)$|12.2 MB|11.93%|

```python
class Solution(object):
    def permuteUnique(self, nums):
        res = []
        def backtrack(nums, temp):
            if len(nums) == 0 and temp not in res:
                res.append(temp)
            for i in range(len(nums)):
                backtrack(nums[:i]+nums[i+1:], temp+[nums[i]])
        backtrack(nums, [])
        return res
```

### 解析2：
和上述方法相似，再递归的时候剪枝，而不是判断是否在res中出现过。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||40 ms|98.37%|
|空间|$O(N!)$|12.3 MB|8.42%|

```python
class Solution(object):
    def permuteUnique(self, nums):
        res = []
        nums = sorted(nums)
        
        def backtrack(nums, temp):
            if len(nums) == 0:
                res.append(temp)
                
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i-1]:
                    continue
                backtrack(nums[:i] + nums[i+1:], temp+[nums[i]])
        
        backtrack(nums, [])
        return res
```
### 解析3：
这种方式应该同样也可以生成全排列，但是顺序被打乱了。

```python
class Solution(object):
    def permuteUnique(self, nums):
        res = list(itertools.permutations(nums))
        res = [''.join(map(lambda x:str(x), x)) for x in res]
        res = list(set(res))
        res = [[x for x in temp] for temp in res]
        return res
```
### 题目：

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

```
示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

### 解析1：
找规律，我们发现，图像旋转，即图像矩阵经过了一次颠倒操作，然后转置。题目的问题是原地操作。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|52 ms|78.46%|
|空间|$O(1)$|13.8 MB|5.06%|

步骤：
1. 对图像矩阵进行颠倒；
2. 图形矩阵进行转置；

```python
class Solution:
    def rotate(self, matrix):
        matrix[:] = matrix[::-1]
        n = len(matrix[0])        
        # transpose matrix
        for i in range(n):
            for j in range(i, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] 
```
### 题目：
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
```
示例:

输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

### 解析1：
将排序字符串作为key，value为相同排序字符串相同的字符串组成的list。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nklogk)$|120 ms|99.03%|
|空间|$O(nk)$|16.6 MB|26.73%|

步骤：
1. 建立一个字典，保存数据，对字符串排序后作为key，原字符串组成的list作为value。
2. 遍历字符串list：
   1. 如果字符串在dict里面，拼接新字符串；
   2. 如果不在，新建key和value将其保存；


```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = dict()
        for str1 in strs:
            temp = ''.join(sorted(str1))
            if temp in res:
                res[temp].append(str1)
            else:
                res[temp] = [str1]
        return res.values()
```

### 解析2：
当数据量大后，这个方法会更好一点，但是需要空间稍大一些。Leetcode上时间更长一些，主要是用例少的原因。  

建议一个list，大小为26，保存没一个数出现的次数，然后将其转变成tuple，如果出现次数相同，则是异位词。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nk)$|172 ms|40.03%|
|空间|$O(nk)$|19 MB|5.13%|

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = dict()
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            count = tuple(count)
            if count in res:
                res[count].append(s)
            else:
                res[count] = [s]
        return res.values()
```
### 题目：
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000

### 解析1：
调用函数实现基本操作。

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return x**n
```

### 解析2：
分治法，不断对其进行二分。当然肯定不如python自己实现的更快。主要注意边界条件，递归时，参数的迭代更新。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|48 ms|71.81%|
|空间|$O(1)$|13.8 MB|5.24%|

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        
        def helper(x,n):
            if n == 0:return 1
            if n%2 == 0:return helper(x*x,n//2)
            return helper(x*x, (n-1)//2)*x
            
        if n >= 0:return helper(x,n)
        return 1/helper(x,-n)
```

### 题目：
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

### 解析1：
暴力法不说了直接动态规划。  
动态规划，f(n)以n为结尾的连续子序列和的最大值，则$f(n) = max(f(n-1)+nums[n], nums[n])$。最后求最大子序列和应该是以n为结尾的子序列和不断求最大。  

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|64 ms|80.14%|
|空间|$O(1)$|12.3 MB|22.73%|


```python
class Solution(object):
    def maxSubArray(self, nums):
        if nums == []:return 0
        n = len(nums)
        res = nums[0]
        temp = nums[0]
        for i in range(1, n):
            temp = max(nums[i], temp+nums[i])
            res = max(res, temp)
        return res
```
### 题目：
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
```
示例 1:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
```

### 解析1：
循环遍历，靠方向数组来实现方向的判断，如果越界，就改变方向，四个方向要按照顺时针方向排布。
* **算法流程：**
  * 1. 因为要遍历整个数组，所以需要遍历m*n次，只不过是每次遍历控制遍历的方向；
  * 2. 设置方向数组，如果遇到边界，或者下一个元素已经遍历过，则改变方向；
  * 3. 因为一共有四个方向，迭代次数di%4来选择方向；

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|40 ms|38.99%|
|空间|$O(mn)$|13.4 MB|33.63%|    


```python
class Solution(object):
    def spiralOrder(self, matrix):
        res = []
        
        if not matrix: return []
        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        
        m,n = len(matrix),len(matrix[0])
        
        seen = [[False]*n for _ in range(m)]

        x = y = di = 0
        for _ in range(m*n):
            res.append(matrix[x][y])
            seen[x][y] = True
            nx = x + dx[di]
            ny = y + dy[di]
            
            if 0 <= nx < m and 0 <= ny < n and not seen[nx][ny]:
                x,y = nx,ny
            else:
                di = (di+1)%4
                x,y = x + dx[di],y + dy[di]          
        return res
```

### 解析2：
逻辑和上述一样，修改经历过的点，用set来保存已经遍历过点。

* **算法复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|24 ms|98.02%|
|空间|$O(mn)$|13.2 MB|36.19%| 

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:return []
        m,n = len(matrix),len(matrix[0])
        x = y = di = 0
        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        res = []
        visited = set()

        for i in range(m*n):
            res.append(matrix[x][y])
            visited.add((x,y))
            nx,ny = x+dx[di],y+dy[di]
            if 0<=nx<m and 0<=ny<n and (nx,ny) not in visited:
                x,y = nx,ny   
            else:
                di = (di+1)%4  # 如果不满足条件，换一个方向进行遍历
                x,y = x+dx[di],y+dy[di]
        return res
```
### 题目：
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。

### 解析1：
动态规划，但是超时了，很迷。复杂度是$O(n^2)$估计需要$O(n)$。

状态含义:dp[i]能否到达第i个位置，如果能到达为1，如果不能到达为0；
状态方程：dp[i] = 1 if dp[i-j]*nums[i-j] >= j else 0 for j in [1,i];   
就是对i前面的数进行遍历，判断能否能否从这个数跳到i，j为距离i这个数的长度。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(n)$| | |


```python
class Solution(object):
    def canJump(self, nums):
        n = len(nums)
        dp = [0] * n
        dp[0] = 1
        for i in range(1,n):
            for j in range(1,i+1):
                if dp[i-j] * nums[i-j] >= j:
                    dp[i] = 1
        return dp[n-1] == 1
```

### 解析2：
贪心法，求每一步能到的最大距离，如果start大于end需要停止，代表无法直接到达start这个位置。start代表跳跃的起始点，end代表跳跃的终点。因为需要判断是否能跳到最后一个点，所以start需要小于n-1。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|67.69%|
|空间|$O(n)$|13.3 MB|54.29%|

```python
class Solution(object):
    def canJump(self, nums):
        n = len(nums)
        start,end = 0,0
        while start <= end and start < n-1:
            end = max(end, nums[start]+start)
            start += 1
        return end >= n-1
```
### 题目：
给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

### 解析1：
算法固定，首先按照第一个元素排序，然后判断前后两个区间是否重叠，如果重叠就合并。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|100 ms|40.89%|
|空间|$O(1)$|14.2 MB|100.00%|

步骤：
1. 按照区间的start（第一个元素）进行排序；
2. 遍历区间集合：
   1. 判断前后两个区间是否存在重叠，如果重叠更新right，区间右端点，直到不重合为止；


```python
class Solution(object):
    def merge(self, intervals):
        intervals = sorted(intervals, key=lambda x:x[0])
        length = len(intervals)
        res = []
        index = 0

        while index < length:
            left = intervals[index][0]
            right = intervals[index][1]
            while index < length-1 and right >= intervals[index+1][0]:
                right = max(right, intervals[index+1][1])
                index += 1
            index += 1
            res.append([left, right])
        return res
```

### 解析2：
思路相同实现起来有点不同，代码更简单。每次比较新的区间和res的最后一个区间的end。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|100 ms|40.89%|
|空间|$O(1)$|14.2 MB|100.00%|


步骤：
1. 对区间按照start排序；
2. 遍历每一个区间：
   1. 如果res为空或者新区间的start大于res最后一个区间的end，则append新的区间；
   2. 否则，更新res最后一个区间的right边界；

    
```python
class Solution(object):
    def merge(self, intervals):
        intervals = sorted(intervals)
        res = []
        i,length = 0,len(intervals)
        while i<length:
            if res==[] or (res[-1][1] < intervals[i][0]):
                res.append(intervals[i])
            else:
                res[-1][1] = max(res[-1][1], intervals[i][1])
            i += 1
        return res
```
### 题目：
给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
```
示例:

输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

### 解析1：
和54思路没啥差别，只不过反向操作，将[1,n**2]遍历，通过一个方向指针来判断方向。增加一个判断条件，是否已经遍历过，对数组进行了赋值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|24 ms|72.99%|
|空间|$O(n)$|11.7 MB|31.63%|

```python
class Solution(object):
    def generateMatrix(self, n):
        list1 = [i for i in range(1,n**2+1)]
        res = [[0]*n for _ in range(n)]
        
        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        
        x = y = di = 0
        for i in range(n**2):
            res[x][y] = list1[i]
            
            nx = x + dx[di]
            ny = y + dy[di]
            
            if 0 <= nx < n and 0 <= ny < n and res[nx][ny] == 0: 
                x,y = nx,ny
            else:
                di = (di+1)%4
                x,y = x + dx[di],y + dy[di]
                
        return res
```
### 题目：
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

### 解析1：
一共有m+n-2步，从左上角到右下角一定,一定向下走m-1步，向右走n-1步，区别在向下向右的顺序。由排列组合可知一共有$C_{m+n-2}^{m-1}$。最美的果然是数学啊。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|20 ms|83.55%|
|空间|$O(1)$|11.7 MB|37.16%|

```python
from math import factorial
class Solution(object):
    def uniquePaths(self, m, n):
        return factorial(m+n-2)/(factorial(m-1)*factorial(n-1))
```

### 解析2：
动态规划需要二次遍历，明显慢于使用排列组合。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|20 ms|83.55%|
|空间|$O(mn)$|11.7 MB|37.16%|

状态含义：dp[i][j] 到达 i, j的最多路径；
状态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]
初始值：dp[0][:]第一行都为1，dp[:][0]第一列都为0；


```python
class Solution(object):
    def uniquePaths(self, m, n):
        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]   
```

### 题目：
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

```python
示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 解析1：
动态规划，需要考虑障碍物的存在，有障碍物存在的地方，将DP值设置为0，其他仍然满足dp的转移方程。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|44 ms|63.00%|
|空间|$O(mn)$|11.8 MB|36.58%|

状态含义：dp[i][j] 到达 i, j的最多路径；
状态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1] 无障碍物的点；0 有障碍物的点；
初始值：dp[0][:]第一行都为1，如果有障碍物存在后面都是0，dp[:][0]第一列都为0，障碍物同理；

```python
class Solution(object):
    def uniquePathsWithObstacles(self, obstacleGrid):
        m,n = len(obstacleGrid),len(obstacleGrid[0])
        
        if obstacleGrid[0][0] == 1:
            return 0
        obstacleGrid[0][0] = 1
        for i in range(1,m):
            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)
        for j in range(1,n):
            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)

        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]
                else:
                    obstacleGrid[i][j] = 0
        return obstacleGrid[m-1][n-1]
```

### 题目：
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。、

```
示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 解析1：
动态规划，明显的前后迭代关系。
状态含义： dp[i][j] 到达 [i,j]两点最小的路径和；
转移方程： dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|116 ms|81.59%|
|空间|$O(mn)$|16.6 MB|5.12%|

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m,n = len(grid),len(grid[0])
        
        dp = [[grid[0][0]]*n for _ in range(m)]
        for i in range(1,n):
            dp[0][i] = dp[0][i-1] + grid[0][i]
            
        for j in range(1,m):
            dp[j][0] = dp[j-1][0] + grid[j][0]
            
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
        return dp[-1][-1]
```
### 题目：
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
```
示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

### 解析1：
直接转成字符串再操作。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|48 ms|79.12%|
|空间|$O(n)$|13.6 MB|5.64%|

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        num = int(''.join(map(str, digits)))+1
        num = list(str(num))
        return map(int, num)
```
### 题目：
实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
```
示例 1:

输入: 4
输出: 2
```

### 解析1：
暴力法，遍历求解是否出现 i**2 <= x and (i+1)**2 > x

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|超时||
|空间|$O(1)$| ||

```python
class Solution(object):
    def mySqrt(self, x):
        i = 0
        while i ** 2 <= x:
            if (i+1)**2 > x:return i
            i += 1
```

### 解析2：
二分法，通过二分查找。主要是很多细节，中位数的选择，左右边界的选择。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|28ms|70%|
|空间|$O(1)$|11.7 MB|12.81%|

```python
class Solution(object):
    def mySqrt(self, x):
        if x == 0:return 0
        left = 0
        right = 99999
        while left < right:
            mid = (left + right + 1)>>1
            if mid **2 > x:right = mid - 1
            else:left = mid
        return left
```
### 题目：
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

>示例 1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

### 解析1：
套用斐波那契数列。主要是起始值和相加的次数。

时间：O(n)
空间：O(1)

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:return 1
        f1,f2 = 1,2
        for i in range(n-2):
            f2,f1 = f1+f2,f2
        return f2
```

好吧，直接调用斐波那契公式的我给满分。
### 题目：
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
```
示例 1:

输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

### 解析1：
动态规划。

状态含义：dp[i][j] word1的前i个单词 转换到 word2的前j个单词 所需的步数；
状态方程： dp[i][j] = dp[i-1][j-1] 如果word1[i]=word2[j]，即这两个单词的位置相等的话；  
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1， dp[i-1][j-1]对应替换操作，将word1[i]替换成word2[j]，dp[i-1][j]对应删除操作，将word1[i]删除掉， dp[i][j-1]对应插入操作。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|236 ms|61.98%|
|空间|$O(n)$|17.7 MB|5.38%|

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n1,n2 = len(word1),len(word2)
        
        dp = [[0]*(n2+1) for _ in range(n1+1)]
        
        for i in range(n2):
            dp[0][i+1] = dp[0][i] + 1
        for i in range(n1):
            dp[i+1][0] = dp[i][0] + 1
            
        for i in range(1, n1+1):
            for j in range(1, n2+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
        return dp[-1][-1]
```
### 题目：
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
```
示例 1:

输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true
```

### 解析1：
240题的特列，可以直接用240题的代码求解。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n + m)$|112 ms|11.74%|
|空间|$O(1)$|13.6 MB|41.11%|

```python
class Solution(object):
    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]:return False
        n,m = len(matrix),len(matrix[0])
        i,j = 0,m-1 
        while i < n and j >= 0:
            if matrix[i][j] == target:return True
            elif matrix[i][j] > target: j -= 1
            else: i += 1
        return False
```

### 解析2：
二分查找，由于整个数组是排序的，可以压缩得到一个list。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(log(mn))$|76 ms|37.19%|
|空间|$O(1)$|13.7 MB|41.11%|

```python
class Solution(object):
    def searchMatrix(self, matrix, target):

        list1 = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                list1.append(matrix[i][j])
            
        return self.binarysearch(list1, target)
    
    def binarysearch(self, nums, target):
        left = 0
        right = len(nums)-1
        while left <= right:
            mid = (left + right)//2
            if nums[mid] == target:
                return True
            elif nums[mid] > target:
                right = mid -1
            elif nums[mid] < target:
                left = mid + 1
        return False
```

### 解析3：
对整个矩阵做我二分查找，一共mn-1个数，根据列表长度值，对应(i,j)坐标。但是竟然更费时。

```python
class Solution:
    def searchMatrix(self, matrix, target):
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        
        #二分查找
        left, right = 0, m * n - 1
        while left <= right:
                pivot_idx = (left + right) // 2
                pivot_element = matrix[pivot_idx // n][pivot_idx % n]
                if target == pivot_element:
                    return True
                else:
                    if target < pivot_element:
                        right = pivot_idx - 1
                    else:
                        left = pivot_idx + 1
        return False
```



### 题目：
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
```
注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

### 解析1：
两次扫描第一次将全部的0移动到前面，第二次从0的下一位开始遍历，将所有的1移动到前面。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|19.09%|
|空间|$O(1)$|12.1 MB|5.21%|

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        zero = 0
        i = 0
        while i < n:
            if nums[i] == 0:
                nums[i],nums[zero] = nums[zero],nums[i]
                zero += 1
            i +=1
        i = one = zero
        while i < n:
            if nums[i] == 1:
                nums[i],nums[one] = nums[one],nums[i]
                one += 1
            i += 1
        
```

### 解析2：
方法类似，修改为一次遍历。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|51.07%|
|空间|$O(1)$|13.8 MB|5.21%|

```Python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        '''
        荷兰三色旗问题解
        '''
        # 对于所有 idx < p0 : nums[idx < p0] = 0
        # curr是当前考虑元素的下标
        p0 = curr = 0
        # 对于所有 idx > p2 : nums[idx > p2] = 2
        p2 = len(nums) - 1

        while curr <= p2:
            if nums[curr] == 0:
                nums[p0], nums[curr] = nums[curr], nums[p0]
                p0 += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr], nums[p2] = nums[p2], nums[curr]
                p2 -= 1
            else:
                curr += 1
```
### 题目：
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

```
示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

### 解析1：
采用滑动窗口的思想。不断滑动右边界窗口，直到满足条件，然后滑动左边界窗口，直接不满足要求，然后再滑动右窗口。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(m+n)$|96 ms|75.43%|
|空间|$O(n+m)$|12.4 MB|27.40%|

步骤：
1. 建立一个字典needs保存目标字符串出现的频率，req为匹配的字符数；
2. 根据右边界遍历字符串：
   1. 保存当前字符到windows字典，如果当前字符char的出现频率和needs[char]相同，匹配数match+1；
   2. 如果匹配数match和req相等，则对左边界进行缩减，同时判断子串的长度，更新res；
   3. 如果被移除的字符并且windows内频率小于needs，则匹配数-1；
3. 对结果加一个判断


```python
class Solution(object):
    def minWindow(self, s, p):
        left, right,match = 0,0,0
        needs = {}
        for char in p:
            needs[char] = needs.get(char,0) + 1
        
        req = len(needs)
        res = float('inf'),None,None
        windows = {}
        while right < len(s):
            char = s[right]
            windows[char] = windows.get(char, 0) + 1
            
            if char in needs and windows[char] == needs[char]:
                match += 1
                
            while left <= right and match == req:
                char = s[left]
                
                if right-left+1 < res[0]:
                    res = (right-left+1, left, right)
                    
                windows[char] -= 1
                if char in needs and windows[char] < needs[char]:
                    match -= 1
                    
                left += 1
            right += 1
        return "" if res[0] == float("inf") else s[res[1] : res[2] + 1]
```

参考链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/
### 题目：
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```
示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 解析1：
和17题非常相似，回溯法即可，两个参数，一个是temp，一个是索引。每次更换备选空间。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间| |744 ms|33.99%|
|空间|$O(n)$|13 MB|41.63%|

```python
class Solution(object):
    def combine(self, n, k):
        res = []
        
        def backtrack(index,temp):
            if len(temp) == k:
                res.append(temp)
            for i in range(index, n+1):
                backtrack(i+1, temp+[i])
        
        backtrack(1, [])
        return res
```

### 解析2：

使用索引来进行修改，改为备选数组。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间| |712 ms|33.99%|
|空间|$O(n)$|13.1 MB|41.63%|


```python
class Solution(object):
    def combine(self, n, k):
        res = []
        nums = list(range(1,n+1))
        
        def backtrack(nums, temp):
            if len(temp) == k:
                res.append(temp)
                
            for i in range(len(nums)):
                backtrack(nums[i+1:], temp+[nums[i]])
        
        backtrack(nums, [])
        return res
```
### 题目：
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

### 解析1：
回溯法，和47.全排列差不多，只不过是选过的元素不能再选了，只能再添加没有选过的元素。同时判断，如果新子集不在res里面才添加，否则不添加。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||60 ms|41.88%|
|空间| |12 MB|21.29%|

```python
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """ 
        res = []
        def backtrack(nums, temp):
            if temp not in res:
                res.append(temp)
            for i in range(len(nums)):
                backtrack(nums[i+1:], temp+[nums[i]])
        backtrack(nums, [])
        return res
```

### 解析2：
采用库函数：`itertools.combinations`。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间||40 ms|99.73%|
|空间| |12 MB|22.36%|

```python
import itertools
class Solution(object):
    def subsets(self, nums):
        res = []
        for i in range(len(nums)+1):
            res.extend(itertools.combinations(nums, i))
        return res
```

### 解析3：
迭代法，即不断循环。设n个数产生的子集$f(n)$，前n-1个数产生子集$f(n-1)$，则$f(n) = f(n-1) + [x+new for x in f(n-1)]$，即$f(n-1)$内的每一个元素加上新的元素。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间| |80 ms|15.02%|
|空间| |14 MB|5.27%|

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        for i in nums:
            res = res + [num+[i] for num in res]
        return res
```
### 题目：
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
```
示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```

### 解析1：
回溯法，选择每一个点作为起点，然后分别进行回溯。

* **算法流程：**：
  1. 遍历board中的每一个点，以每个点作为起点；
  2. 设置回溯函数，判断是否存在单词路径，函数参数：坐标点，i，j，已经相同的点数和遍历过的点；
  3. 如果当前元素等于word，并且回溯函数返回True，才确定存在路径；
  4. 若能遍历完所有的点，则返回True，向四周遍历，判断是否存在下一个有效点；
  5. 如果i，j没有越界，并且这个点没有遍历过，且和word[k]相同，则对下一个点进行递归（回溯）；
  6. 如果当前路径不存在有效路径，要在visited中清除当前点；

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O((mn)^2)$|308 ms|86.39%|
|空间|$O(mn)$|15.1 MB|11.65%|
关于回溯法的复杂度比较麻烦，此处不是很清楚。

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        n,m = len(board),len(board[0])
        def dfs(i,j,k,visited):
            if k == len(word):return True
            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:
                nx,ny = i+dx,j+dy
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited and board[nx][ny] == word[k]:
                    visited.add((nx,ny))
                    if dfs(nx, ny, k+1,visited):
                        return True
                    visited.remove((nx, ny))
            return False
        for i in range(n):
            for j in range(m):
                if board[i][j] == word[0] and dfs(i,j,1,{(i,j)}):
                    return True
        return False
```


### 解析2：
相比上述解法，降低了空间复杂度，将经历过的点，用其他符号代替，如果该路径走不通再替换回来。

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            tmp, board[i][j] = board[i][j], '*' # 把经历过的点用“*”代替，这样将不会再次遍历
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = tmp  # 如果不成立，则再还原回去
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```
### 题目：
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
示例:

输入: [2,1,5,6,2,3]
输出: 10
```

### 解析1：
暴力法遍历所有的子数组，然后比较面积大小，直接超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时||
|空间|$O(n)$|| |

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        res = 0
        for i in range(n):
            for j in range(i,n):
                temp = heights[i:j+1]
                res = max(res, min(temp)*(j-i+1))
        return res
```

### 解析2：
对上述做法进行优化，子数组的起点确定后，用之前的最低高度，和当前的最低高度来求。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(n)$|| |

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        res = 0
        for i in range(n):
            minh = float('inf')
            for j in range(i,n):
                minh = min(minh, heights[j])
                res = max(res, minh*(j-i+1))
        return res
```


### 解析3：
以i为中心进行拓展，找到比heights[i]小的边界，得到的矩形便是以heights[i]为高，right-left-1的矩形。但是依然超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(n)$|| |

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        res = 0
        for i in range(n):
            left, right = i,i
            while left >= 0 and heights[left] >= heights[i]:
                left -= 1
            while right < n and heights[right] >= heights[i]:
                right += 1
            res = max(res, (right-left-1)*heights[i])
        return res
```

### 解析4：
使用栈依次保存单调递增序列，遇到递减序列后，将其pop，依次更新最大面积。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|156 ms|55.46%|
|空间|$O(n)$|15.7 MB|27.69%|

步骤：
1. 遍历整个数组；
2. 将数组依次保存在一个栈中，不断将递增的序号放入栈中，直到递减序列出现heights[i-1]>heights[i];
3. 然后将栈中元素依次pop出，直到heights[stack[j]]< heights[i];
4. 此时最大的矩形高度是heights[stack.pop()]，宽度是i-stack.pop()[-1]-1;


```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        heights = [0] + heights + [0]
        res = 0
        for i in range(len(heights)):
            #print(stack)
            while stack and heights[stack[-1]] > heights[i]:
                tmp = stack.pop()
                res = max(res, (i - stack[-1] - 1) * heights[tmp])
            stack.append(i)             
        return res
```
### 题目：
给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```
示例:

输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
```


### 题目：
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
```
示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 解析1：
排序后赋值在nums1中。对原nums1进行修改。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O((m+n)log(m+n))$|28 ms|81.99%|
|空间|$O(m+n)$|11.7 MB|25.63%|   

```python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        nums1[:] = sorted(nums1[:m] + nums2)
```

### 解析2：
归并思路。将nums1复制，然后依次和nums2比较，选择较小的，放在nums1里面。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(m+n)$|24 ms|93.99%|
|空间|$O(m+n)$|11.8 MB|15.63%|   

```python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        nums1_copy = nums1[:m]
        nums1[:] = []
        p1,p2 = 0,0
        while p1 < m and p2 < n:
            if nums1_copy[p1] <= nums2[p2]:
                nums1.append(nums1_copy[p1])
                p1 += 1
            else:
                nums1.append(nums2[p2])
                p2 += 1
        if p1 < m:
            nums1[p1+p2:] = nums1_copy[p1:]
        if p2 < n:
            nums1[p1+p2:] = nums2[p2:]
```
### 题目：
给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。
```
示例:

输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

### 解析1：
回溯法，套用模板。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O()$|32 ms|74.57%|
|空间|$O(1)$|12 MB|18.85%|

```python
class Solution(object):
    def subsetsWithDup(self, nums):
        nums = sorted(nums)
        res = []

        def backtrack(nums, temp):
            if temp not in res:
                res.append(temp)
            
            for i in range(len(nums)):
                if i>0 and nums[i] == nums[i-1]:
                    continue
                else:
                    backtrack(nums[i+1:], temp+[nums[i]])
                    
        backtrack(nums, [])
        return res
```
### 题目：
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。
```
示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

### 解析1：
链表未到达要翻转的地方之前，类似链表遍历，向前移动即可。遇到反转的起点，翻转链表，直到反转结束点。对指针的要求比较高。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|20 ms|84.42%|
|空间|$O(n)$|12 MB|18.93%|

```python
class Solution:
    def reverseBetween(self, head, m, n):
        # Empty list
        if not head:
            return None

        # Move the two pointers until they reach the proper starting point
        # in the list.
        cur, prev = head, None
        
        while m > 1:
            prev = cur
            cur = cur.next
            m, n = m - 1, n - 1

        # The two pointers that will fix the final connections.
        tail, con = cur, prev

        # Iteratively reverse the nodes until n becomes 0.
        while n:
            third = cur.next
            cur.next = prev
            prev = cur
            cur = third
            n -= 1

        # Adjust the final connections as explained in the algorithm
        if con:
            con.next = prev
        else:
            head = prev
        tail.next = cur
        return head

```

### 题目：
给定一个二叉树，返回它的中序 遍历。

```
示例:
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

### 解析1：
DFS没啥好说的，递归遍历，先左子树，然后根结点，然后右子树。递归的代码写起来更简单一些。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|36 ms|7.64%|
|空间|$O(n)$|11.8 MB|23.52%|


```python
class Solution(object):
    def inorderTraversal(self, root):
        res = []
        def dfs(root):
            if not root:
                return None
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)
        dfs(root)
        return res
```

### 解析2：
迭代遍历，用栈依次保存结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|60.07%|
|空间|$O(n)$|11.9 MB|6.41%|

```python
class Solution:
    def inorderTraversal(self, root):
        res = []
        stack = []
        # 用p当做指针
        p = root
        while p or stack:
            # 把左子树压入栈中
            while p:
                stack.append(p)
                p = p.left
            # 输出 栈顶元素
            tmp = stack.pop()
            res.append(tmp.val)
            # 看右子树
            p = tmp.right
        return res
```


### 知识点：
树的遍历：
深度优先DFS:
* 前序遍历：根左右(Leetcode144)
* 中序遍历：左根右(Leetcode94)
* 后序遍历：左右根(Leetcode145)

广度优先BFS


### 题目：
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
```
示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

### 解析1：
公式法，直接推到出具体的公式：$C_0 = 1,C_{n+1} = \frac{2(2n+1)}{n+2}C_n$  

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|53.42%|
|空间|$O(N!)$|11.8 MB|29.63%|

```python
class Solution(object):
    def numTrees(self, n):
        res = 1
        for i in range(n):
            res = res * 2*(2*i+1)/(i+2)
        return int(res)
```
### 题目：
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```
示例 1:

输入:
    2
   / \
  1   3
输出: true
```

### 解析1：
中序遍历，二叉搜索树的中序遍历将会得到一个递增的序列。对二叉树做中序遍历，判断是否是递增序列即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|48 ms|48.21%|
|空间|$O(n)$|17.5 MB|5.07%|

```python
class Solution(object):
    def isValidBST(self, root):
        res = []

        def dfs(root):
            if not root:return None
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return res == sorted(list(set(res)))
```

### 解析2：
递归。依次遍历

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|42.21%|
|空间|$O(n)$|17.4 MB|5.07%|

```python
class Solution(object):
    def isValidBST(self, root):
        def helper(node, lower=float('-inf'), higher = float('inf')):
            if not node:return True
            val = node.val
            if val <= lower or val >= higher:
                return False
            if not helper(node.left, lower, val):
                return False
            if not helper(node.right, val, higher):
                return False
            return True

        return helper(root)
```
### 题目：
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
```
示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

### 解析1：
递归判断，先判断根节点是否相同，然后递归的判断左右子树是否相同。主要是根节点的判断。1.根节点是否都为空；2.是否一个为空。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|60.56%|
|空间|$O(1)$|11.9 MB|21.12%|

```python
class Solution(object):
    def isSameTree(self, p, q):
        if p == None and q == None:
            return True
        if p == None or q == None:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
### 题目：
给定一个二叉树，检查它是否是镜像对称的。
```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
```

### 解析1：
**设置dfs辅助函数，比较左子树结点和右子树结点是否是相等的，以及左右子树是否对称。**--再判断左子树的右结点和右子树的左结点是否是相等的，左子树的左结点和右子树的右结点是否是相等的。

* **算法流程：**
  1. 设置辅助函数，来判断两棵树是否相等。如果两棵树均为空返回True；
  2. 如果两棵树一个为空，一个不为空，则返回False；
  3. 判断两棵树结点值是否相等、左树的左结点和右树的右结点是否相等、左树的右结点和右树的左结点是否相等。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|12.15%|
|空间|$O(n)$|12.1 MB|10.14%|

```python
class Solution(object):
    def isSymmetric(self, root):
        def dfs(left,right):
            if not left and not right:return True
            if not left or not right:return False
            
            return left.val == right.val and \
                 dfs(left.left, right.right) and \
                dfs(left.right, right.left)
        return dfs(root, root)
```
### 题目：

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
```
例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

### 解析1：
简单BFS遍历，每一层的保存在一个list里面要。

* **算法流程：**
1. 建立一个队列保存每层的结点，res保存最终结果；
2. 遍历队列，先入先出，遍历每一层的结点值，直到queue为空。
   1. 每次遍历每层的结点，将其一起保存在队列中，入队的结点先出队，直到该层遍历结束。
   2. 遍历每层结点时，保存当前结点值，同时判断左右结点是否为空，将新结点入队。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|98.27%|
|空间|$O(1)$|12.2 MB|25.04%|


```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if not root:return None
        
        queue = [root]
        while queue:
            temp = []
            for _ in range(len(queue)):
                root = queue.pop(0)
                temp.append(root.val)
                if root.left:queue.append(root.left)
                if root.right:queue.append(root.right)
            res.append(temp)
        return res
```

### 解析2：
递归实现，很迷，递归好快啊，比迭代快很多。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|16 ms|99.45%|
|空间|$O(1)$|12.6 MB|5.08%|


```python
class Solution:
    def levelOrder(self, root):
        levels = []
        if not root:
            return levels

        def helper(node, level):
        # node：当前层的对应根节点，level当前层的深度
            if len(levels) == level:
                levels.append([])

            levels[level].append(node.val)

            if node.left:
                helper(node.left, level + 1)
            if node.right:
                helper(node.right, level + 1)
            
        helper(root, 0)
        return levels
```



### 题目：
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
```
例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]
```

### 解析1：
和上一题层次遍历差不多，只是加一个层的判断，奇数和偶数层的处理不同，增加一个判断即可。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|97.71%|
|空间|$O(n)$|13.8 MB|5.96%|

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:return None
        res,queue = [],[root]
        layer = 0
        while queue:
            temp = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                temp.append(node.val)
                if node.right:queue.append(node.right)
                if node.left:queue.append(node.left)   
            
            if layer%2 == 0:res.append(temp[::-1])
            else:res.append(temp)
            layer += 1
        return res
```
### 题目：
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

### 解析1：
递归遍历每一个结点，比较左右子树的深度大小，返回左右子树较大值+1.

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|80.45%|
|空间|$O(logn)$|15 MB|24.81%|

每一次递归调用都需要保存到栈里面，正常二叉树的层数Logn即可。

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        left = self.maxDepth(root.left) 
        right = self.maxDepth(root.right)
        return left + 1 if left>right else right + 1

# 优化后的代码
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

### 解析2：
迭代实现，遍历每一个结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|68 ms|51.04%|
|空间|$O(logn)$|15 MB|86.14%|

```python
class Solution:
    def maxDepth(self, root):
        stack = []
        if root is not None:
            stack.append((1, root))
        
        depth = 0
        while stack != []:
            current_depth, root = stack.pop()
            if root is not None:
                depth = max(depth, current_depth)
                stack.append((current_depth + 1, root.left))
                stack.append((current_depth + 1, root.right))
        
        return depth
```
### 题目：
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。
```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```
### 解析1：
求根结点，然后得到左子树的前序遍历和中序遍历，对左子树递归调用。求右子树的前序遍历和中序遍历，右子树递归调用。

* **算法流程：**
  1. 如果前序遍历或中序遍历为空返回None；
  2. 前序遍历的第一个元素是根节点，求根节点；
  3. 获取根节点在中序遍历的索引，即根节点在中序遍历中的位置；
  4. 左子树的前序遍历：preorder[1:1+index],中序遍历：inorder[:index]
  5. 右子树的前序遍历：preorder[1+index:],中序遍历：inorder[index+1:]

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|184 ms|83.18%|
|空间|$O(n)$|86.2 MB|26.87%|


```python
class Solution(object):
    def buildTree(self, preorder, inorder):
        if not preorder or not inorder:return None
        val = preorder[0]
        root = TreeNode(val)
        index = inorder.index(val)
        root.left = self.buildTree(preorder[1:1+index], inorder[:index])
        root.right = self.buildTree(preorder[1+index:], inorder[index+1:])
        return root
```
### 题目：
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出
```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

### 解析1：
和第105题一样，获取根节点，以及划分好左右子树。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|220 ms|40.65%|
|空间|$O(n)$|86.2 MB|30.30%|


```python
class Solution(object):
    def buildTree(self, inorder, postorder):
        if not inorder or not postorder:return None
        val = postorder[-1]
        # print(val, inorder, postorder)
        index = inorder.index(val)
        root = TreeNode(val)
        
        root.left = self.buildTree(inorder[:index], postorder[:index])
        root.right = self.buildTree(inorder[index+1:],postorder[index:-1])
        return root    
```
### 题目：
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
```
示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

### 解析1：
取每一个数组的中位数作为根节点，然后对前半部分遍历，作为左子树，右半部分遍历作为右子树。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|92 ms|78.67%|
|空间|$O(n)$|16.1 MB|5.59%|

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:return None
        mid = (len(nums)-1)//2
        res = TreeNode(nums[mid])
        
        res.left = self.sortedArrayToBST(nums[:mid])
        res.right = self.sortedArrayToBST(nums[mid+1:])
        return res
```
### 题目：

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```
示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

### 解析1：
遍历每个树的结点，然后求其左右子树的深度差是否小于1。依次对每个树遍历执行相同的操作。左右子树都满足要求才可以。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|84 ms|67.26%|
|空间|$O(logn)$|18.6 MB|26.14%|

* **算法流程：**
1. 辅助函数求根节点左右子树的深度，判断深度差是否小于1；
2. 左右子树深度差小于1，同时左右子树是平衡树    ；


```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        left = self.rootDepth(root.left)
        right = self.rootDepth(root.right)
        
        if abs(left - right) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)
        
    def rootDepth(self,root):
        if not root:
            return 0
        right = self.rootDepth(root.right)
        left = self.rootDepth(root.left)
        
        return left + 1 if left > right else right + 1

# 优化后的结果
class Solution:
    def maxDepth(self, root):
        if not root:return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:return True
        # if not root.left or not root.right:return True # 这句话是错误的不能加
        return abs(self.maxDepth(root.left)-self.maxDepth(root.right))<2 and self.isBalanced(root.left) and self.isBalanced(root.right)
```

### 解析2：
* **算法流程：**

采用递归的方式，上述方法是自顶向下的，不停计算每个结点的深度值，需要计算两边。下面自底向上的方法的，相当于在求结点的深度的时候，同时判断是否是平衡树。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|64 ms|98.16%|
|空间|$O(logn)$|19.7 MB|5.15%|

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        self.res = True
        def helper(root):
            if not root:
                return 0
            left = helper(root.left) + 1
            right = helper(root.right) + 1
            if abs(left - right) > 1:
                # 需要定义一个全局变量
                self.res = False
            return max(left, right)
        helper(root)
        return self.res
```
### 题目：
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。
```
示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2
```

### 解析1：

* **算法流程：**
使用队列，BFS迭代遍历，如果左右子树都不存在，返回层数，即为最小深度。

* **算法流程：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|68 ms|21%|
|空间|$O(logn)$|14.7 MB|45.14%|

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:return 0
        res = 0
        queue = [root]
        while queue:
            res += 1
            for _ in range(len(queue)):
                node = queue.pop(0)
                if not node.left and not node.right:return res
                if node.left:queue.append(node.left)
                if node.right:queue.append(node.right)
        return res
```

### 解析2：
递归法求解。
* **算法流程：**
  * 1.如果root为空，返回0；
  * 2.如果root.left和root.right都为空，返回1；
  * 3.如果左子树不为空，求左子树的最小深度然后+1；如果右子树不为空，。。同样逻辑。

* **算法流程：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|68 ms|21%|
|空间|$O(logn)$|14.7 MB|45.14%|

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:return 0
        if not root.left and not root.right:return 1
        res = float('inf')
        if root.left:res = min(res, self.minDepth(root.left))
        if root.right:res = min(res, self.minDepth(root.right))
        return res + 1
```
### 题目：
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

```
示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

### 解析1：
递归写法，每次减去当前节点的值，到达叶子结点时，判断sum是否为0.

* **算法流程：**
1. 判断根节点是否为空，如果为空返回False；
2. 如果不为空，修改target，如果是叶结点，并且和为0，返回True；
3. 递归遍历左子树和右子树，如果出现某个分支返回True则为True；

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|36 ms|84.68%|
|空间|$O(n)$|15.5 MB|21.20%|

```python
class Solution(object):
    def hasPathSum(self, root, target):  
        if not root:return False
        target -= root.val
        if not root.left and not root.right and target == 0:
            return True
        return self.hasPathSum(root.left, target) or self.hasPathSum(root.right, target)
```


自己的代码，和113题类似，dfs遍历，然后判断是否为0.
```python
class Solution:
    def hasPathSum(self, root: TreeNode, target: int) -> bool:
        self.res = False
        def dfs(root,temp):
            if not root:return None
            if not root.left and not root.right and temp == 0:
                self.res = True
            if root.left:dfs(root.left,temp-root.left.val)
            if root.right:dfs(root.right, temp-root.right.val)
            
        if not root:return False
        dfs(root,target-root.val)
        return self.res
```
### 解析2：
迭代实现，建立一个栈，保存遍历到每个节点的元组（node, sum-node.val）。遍历到叶节点，并且sum为0，则为True。相比迭代快了很多。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|69.20%|
|空间|$O(n)$|15.4 MB|34.78%|

步骤：
1. 使用栈来依次保存每个元组，将元组（node, sum-node.val）保存在栈中；
2. 遍历栈：
   1. 每次出栈最新加入的结点，相当于不断做dfs；
   2. 判断是否是叶结点，以及sum是否为0；
   3. 深挖，依次添加右子树和左子树；


```python
class Solution(object):
    def hasPathSum(self, root, sum):
        if not root:
            return False
        queue = [(root, sum-root.val)]

        while queue:
            node,temp_sum = queue.pop()
            if not node.left and not node.right and temp_sum==0:
                return True
            if node.right:
                queue.append((node.right, temp_sum-node.right.val))
            
            if node.left:
                queue.append((node.left, temp_sum-node.left.val))
        return False
```
### 题目：
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

```
示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

### 解析1：
路径总和，采用递归的方法，其实依然是dfs，在深度优先遍历的时候添加一些限制和变量。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|47.77%|
|空间|$O(n)$|18.8 MB|16.14%|

* **算法流程：**
1. 深度遍历，dfs,遍历的同时，判断路径是否满足需求；
2. 每次遍历，不只是res.append(root.val)，判断是否是叶节点，以及路径和是多少；


```python   
class Solution(object):
    def pathSum(self, root, sum):

        res = []
        if not root: return []
        def dfs(root, sum, tmp):
        # sum：到目前结点所需要满足的目标和；
        # tmp：到目前结点的结点路径；
            if not root:
                return 
            if not root.left and not root.right and sum - root.val == 0 :
                tmp += [root.val]
                res.append(tmp)
                return
            dfs(root.left, sum - root.val, tmp + [root.val])
            dfs(root.right, sum - root.val, tmp + [root.val])
        dfs(root, sum, [])
        return res
```

相比上述代码更加简洁，dfs传入root和temp两个参数。

```python
class Solution:
    def pathSum(self, root: TreeNode, target: int) -> List[List[int]]:
        self.res = []
        def dfs(root, temp):
            if not root:return None
            if not root.left and not root.right and sum(temp)==target:self.res.append(temp)
            if root.left:dfs(root.left,temp+[root.left.val])
            if root.right:dfs(root.right,temp+[root.right.val])
        if not root:return []
        dfs(root,[root.val])
        return self.res
```
### 题目：
给定一个二叉树，原地将它展开为链表。

```
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

### 解析1：
前序遍历，但是要原地修改，所以会比较麻烦。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|72.62%|
|空间|$O(n)$|13.8 MB|5.71%|

1. 修改当前结点的左右子树，right指向左子树，left指向None；
2. 对所有结点进行递归操作，保存root.right值
```python
class Solution:
    def __init__(self):
        self.pre = None
    def flatten(self, root: TreeNode) -> None:
        if not root: return
        # self.pre保存上一层的结点，更新上一层结点的左子树和右子树；

        if self.pre: self.pre.right, self.pre.left = root, None
        self.pre = root
        right = root.right
        self.flatten(root.left)
        self.flatten(right)
```
### 题目：
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

```
示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

### 解析1：
遍历上一层，然后构建下一层的结果即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|40 ms|95.12%|
|空间|$O(n)$|13.8 MB|5.99%|

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:return []
        res = [[1]]
        for i in range(1,numRows):
            temp = [1]
            last = res[-1]
            for i in range(len(last)-1):
                temp.append(last[i]+last[i+1])
            temp.append(1)
            res.append(temp)
        return res
```
### 题目：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

>示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

### 解析1：
暴力法，遍历每一天的股票，然后求后面几天的最大值，求差，再和res比较大小。直接超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(1)$| | |

```python
class Solution(object):
    def maxProfit(self, prices):
        res = 0
        length = len(prices)
        for i in range(length-1):
            res = max(max(prices[i+1:]) - prices[i],res)
        return res
```

### 解析2：

遍历一次的办法。保存到目前为止的最小值，以及最大利润。最大利润的产生即当前值减去以前的最小值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|64 ms|72.77%|
|空间|$O(1)$|12.5MB|37.76%|

步骤：
1. 两个变量minprice，maxprofit分别保存到目前为止的最小价格和最大利润；注意最小值应该从第一个元素开始。
2. 遍历数组，更新最小值和最大利润。

```python
class Solution(object):
    def maxProfit(self, prices):
        if prices == []:
            return 0
        minprice = prices[0]
        maxprofit = 0
        for num in prices:
            minprice = min(minprice, num)
            maxprofit = max(maxprofit, num-minprice)
        return maxprofit
```


### 解析3：
动态规划模板去写。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|116 ms|5.47%|
|空间|$O(1)$|12.7MB|14.56%|

**状态转移方程：**
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp0 = max(dp0, dp1+prices[i])  
第i天未持有股票获得的最多利润 = max(第i-1天未持有股票获得的最多利润， 第i-1天持有股票获得的最多利润 卖掉 prices[i])

dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])

第i天持有股票获得的最多利润 = max(第i-1天持有股票获得的最多利润， 第i-1天未持有股票获得的最多利润 买入 prices[i])，因为只能买入一次，所以如果第i次买入的话前面的利润都是0，所以dp[i-1][0]=0.

dp[i][1] = max(dp[i-1][1], -prices[i])
dp1 = max(dp1, -prices[i])
```


```python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        length = len(prices)
        dp0,dp1 = 0, -prices[0]
        
        for i in range(1, length):
            dp0 = max(dp0, dp1+prices[i])
            dp1 = max(dp1, - prices[i])
        return dp0
```

###解析3：
可以转化成连续子数组求最大和问题。将数组相邻的值做差，即代表前后买卖股票的收益，如果小于0则不发生买卖，收益为0。然后再求最大连续子数组和，即代表最大收益。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|36.51%|
|空间|$O(1)$|12.9MB|5.92%|

```python
class Solution(object):
    def maxProfit(self, prices):
        profit = []
        length = len(prices)
        for i in range(length-1):
            profit.append(prices[i+1]-prices[i])
        curProfit = 0
        maxProfit = 0
        for i in range(len(profit)):
            curProfit = max(curProfit+profit[i], profit[i])
            maxProfit = max(maxProfit, curProfit)
        return maxProfit
```



### 题目：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

>示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

### 解析1：
我们需要寻找的是波峰波谷，多个波谷到波峰峰相加肯定大于单纯的波谷到波峰。以[7, 1, 5, 3, 6, 4]为例，从1-5,3-6两次买卖，肯定大于1-6。如果一直上涨，波峰就一直向后延，直到碰到不满足prices[i+1]>peak为止。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|97.9%|
|空间|$O(1)$|12.5MB|37.74%|

步骤：
1. 从波谷开始，发现连续上涨的阶段，一直延后，直到波峰，中间不接受波动；
2. 添加每一段到波谷到波峰到res。

```python
class Solution(object):
    def maxProfit(self, prices):
        if prices == []:
            return 0
        i,res,length = 0,0,len(prices)

        while i < length:
            valley = prices[i]
            peak = prices[i]
            while i < length-1 and prices[i+1] > peak:
                peak = prices[i+1]
                i += 1
            res += peak - valley
            i += 1
        return res        
```

### 解析2：
实现起来更加简洁，如果某一天比前一天高即认为是有效交易。由于没有交易次数和交易时间的限制，只要明天比今天价格高即可交易。实现起来非常简洁，但是运行速度却比较慢。由于寻找波峰只是在做比较操作，所以避免了很多比较和求和操作，方法1更快一些。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|84 ms|20.20%|
|空间|$O(1)$|12.7MB|23.25%|

```python
class Solution(object):
    def maxProfit(self, prices):
        res = 0
        for i in range(len(prices)-1):
            temp = prices[i+1] - prices[i]
            if temp > 0:
                res += temp
        return res
```

### 解析3：
动态规划，分析方式依然和121题是相似的。一个方法比一个方法慢，虽然是动态规划，貌似所有股票类型题目可以大一统，但是速度比较慢。

**状态转移方程：**
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp0 = max(dp0, dp1+prices[i])  
第i天未持有股票获得的最多利润 = max(第i-1天未持有股票获得的最多利润， 第i-1天持有股票获得的最多利润 卖掉 prices[i])

dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
dp1 = max(dp1, dp0-prices[0])
第i天持有股票获得的最多利润 = max(第i-1天持有股票获得的最多利润， 第i-1天未持有股票获得的最多利润 买入 prices[i])
```

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|92 ms|15.59%|
|空间|$O(1)$|12.6MB|31.28%|

```python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        
        length = len(prices)
        dp0,dp1 = 0, -prices[0]
        
        for i in range(1, length):
            temp = dp0
            dp0 = max(dp0, dp1+prices[i])
            dp1 = max(dp1, temp - prices[i])
        return dp0
```
### 题目：
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

>示例 1:
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

### 解析1：
限制只能两次交易，所以两次的状态转移方程分开建立。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|68 ms|97.84%|
|空间|$O(1)$|12.6MB|35.22%|


```python
class Solution:
    def maxProfit(self, prices):
        if not prices:
            return 0

        len_prices = len(prices)
        buy1, sell1, buy2, sell2 = -prices[0], 0, -prices[0], 0

        for i in range(1, len_prices):
            buy1 = max(buy1, -prices[i])
            sell1 = max(sell1, buy1 + prices[i])
            buy2 = max(buy2, sell1 - prices[i])
            sell2 = max(sell2, buy2 + prices[i])
        return sell2
```
### 题目：
给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
```
示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

### 解析1：
递归求解，建立一个函数，自底向上，求解以当前节点作为根节点的最大路径和。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|108 ms|96.77%|
|空间|$O(logn)$|22.3 MB|5.00%|

```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.res = float('-inf')
        def helper(root):
            if not root:return 0
            # 求解以左结点为根结点的最大路径和
            left = helper(root.left)
            # 以右结点为根结点的路径和
            right = helper(root.right)
            
            # 更新全局变量
            self.res = max(left + right + root.val,self.res)
            # 当前节点到叶结点，单条路径的最大路径和
            return max(0, max(left, right)+root.val)
        
        helper(root)
        return self.res
```
### 题目：
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。
```
示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true
示例 2:

输入: "race a car"
输出: false
```

### 解析1：
做一下筛选，然后再判断是否相等。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|97.88%|
|空间|$O(n)$|14.9 MB|12.56%|

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        s = [x for x in s if x.isalpha() or x.isdigit()]
        s = ''.join(s)
        
        return s == s[::-1]
```
### 题目:
给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 O(n)。
```
示例:

输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

### 解析1：
去重，然后排序，求最长连续序列长度，判断是否相邻。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|72 ms|82.70%|
|空间|$O(1)$|15 MB|5.09%|

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums = sorted(set(nums))

        n = len(nums)
        if n < 2:
            return n
        res = 1
        temp = 1
        for i in range(1,n):
            
            if nums[i] - nums[i-1] <= 1:
                temp += 1
                res = max(res, temp)
            else:
                temp = 1
        return res
```

### 解析2：
将数保存在set中，遍历set，如果num-1不在set中，以num为连续序列的开始，做遍历。对于连续序列中间的数，因为num-1在set中，所以不会开始后面的循环。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|82.70%|
|空间|$O(1)$|15 MB|5.09%|

步骤：
1. 对nums取set，遍历数组（set）；
   1. 如果num-1不在set中，则启动后面的循环，将其作为连续序列的开始，求连续序列的长度；
   2. 求连续序列的最大长度，求结果；

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums = set(nums)
        res = 0
        for num in nums:
            if num-1 not in nums:
                end_num = num + 1
                while end_num in nums:
                    end_num += 1
                res = max(res, end_num-num)
        return res
```
### 题目：

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。
```
示例:

输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

### 解析1：
回溯法，注意回溯模板，主要还是利用模板，这种题目很套路。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|96 ms|94.33%|
|空间|$O(n)$|13.8 MB|5.05%|

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        def helper(s, temp):
            if s == '':
                res.append(temp)
            else:
                for i in range(1,len(s)+1):
                    if s[:i] == s[:i][::-1]:
                        helper(s[i:], temp + [s[:i]])
        helper(s, [])
        return res 
```
### 题目：
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```
示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```

### 解析1：
遍历数组，统计次数，遍历字典。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|164 ms|13.24%|
|空间|$O(n)$|15 MB|5.02%|


```python
class Solution(object):
    def singleNumber(self, nums):
        cnt_dict = {}
        for num in nums:
            cnt_dict[num] = cnt_dict.get(num, 0) + 1
        for key,value in cnt_dict.items():
            if value == 1:
                return key
        return -1
```

思路和上述类似，建立一个哈希表保存出现过的数，如果这个数出现过则在哈希表中移除这个数，如果没出现过则添加这个数。由于只有一个数出现过一次，其他均出现过两次，最后剩下的就是只出现过一次的元素。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|132 ms|24.65%|
|空间|$O(n)$|13.9 MB|6.63%|

```python
class Solution(object):
    def singleNumber(self, nums):
        num_set = set()
        for num in nums:
            if num not in num_set:
                num_set.add(num)
            else:
                num_set.remove(num)
        
        return num_set.pop()
```
### 解析2：
数学公式求解。$2(a+b+c) - (a + a + b + b + c) = c$

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|132 ms|24.65%|
|空间|$O(n)$|13.9 MB|6.63%|

```python
class Solution(object):
    def singleNumber(self, nums):
        return 2*sum(set(nums)) - sum(nums)
```

### 解析3：
位运算，利用异或，二进制异或，相同为0，不同为1。出现过两次的元素异或得到0，0和只出现过一次的元素异或得到它本身。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|80 ms|98%|
|空间|$O(1)$|13.7 MB|17.47%|

```python
class Solution(object):
    def singleNumber(self, nums):
        n = len(nums)
        if n  == 0:
            return 0
        a = nums[0]
        for i in range(1,n):
            a ^= nums[i]
        return a
```

### 二进制复习：
* 和0异或得到本身：$a \oplus 0 = a$
* 相同的数异或得到0：$a \oplus a = 0$
* XOR 满足交换律和结合律：$a \oplus b \oplus a = (a \oplus a) \oplus b = 0$


### 题目：
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```
示例 1:

输入: [2,2,3,2]
输出: 3
```

### 解析1：
依然是统计次数，然后判断，用烂的套路。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|83.72%|
|空间|$O(n)$|14.6 MB|5.45%|


```python
class Solution(object):
    def singleNumber(self, nums):
        cnt_dict = {}
        for num in nums:
            cnt_dict[num] = cnt_dict.get(num, 0) + 1
        for key,value in cnt_dict.items():
            if value == 1:
                return key
        return -1
```

### 解析2：
数学公式：$3(a+b+c) - (3×a + 3×b + c) = 2×c$

```python
class Solution(object):
    def singleNumber(self, nums):
        return (3*sum(set(nums)) - sum(nums))//2
```

### 解析3：
依然是位运算，好吧还是您牛逼，认输。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|48ms|98%|
|空间|$O(n)$|13MB|40.45%|

```python
class Solution:
    def singleNumber(self, nums):
        ones, twos = 0, 0
        for num in nums:
            ones = ones ^ num & ~twos
            twos = twos ^ num & ~ones
        return ones
```
### 题目：
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
```
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

### 解析1：
动态规划，确定状态含义和转移方程即可。
状态含义：dp[i] 表示前i个词是否可以由wordDict组成；
转移方程：dp[i] = if dp[j] and s[j:i] in wordDict for j in range(0,i)
遍历0-i个位置，判断s[j:i]是否在wordDict，同时判断dp[j]是否为真。


```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        if not wordDict:return False
        n = len(s)
        dp = [False for _ in range(n+1)]
        dp[0] = True
        wordDict = set(wordDict)
        for i in range(1,n+1):
            for j in range(i-1, -1,-1):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
        return dp[n]
```

### 题目：
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。


示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

### 解析1：
快慢指针。设置快慢指针，如果两个再次重合则存在环。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|99.61%|
|空间|$O(n)$|18.3 MB|5.65%|

步骤：
1. 设置快慢指针均从从head开始；
2. 循环标志，fast和fast.next不为空，如果出现fast和slow再次相等则为环形。

```python
class Solution(object):
    def hasCycle(self, head):
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

### 解析2：
遍历链表，如果不是奇葩值便修改成奇葩值，如果能出现重复的奇葩值，便是环形链表。不合常理，理论上解析2应该比解析1速度更快。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|85.11%|
|空间|$O(n)$|18.1 MB|32.48%|

```python
class Solution(object):
    def hasCycle(self, head):
        if not head:
            return False
                
        while head:
            if head.val == 'like': return True
            else: head.val = 'like'
            head = head.next
        return False
```

### 解析3：
遍历链表，依次将链表结点保存在一个Hash表中，如果新结点在Hash表中出现过，则出现了环，否则环不存在。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|48 ms|71.11%|
|空间|$O(n)$|18.5 MB|5.48%|

```python
class Solution(object):
    def hasCycle(self, head):
        node = set()
        while head:
            if head in node:
                return True
            node.add(head)
            head = head.next
        return False
```

### 题目：
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。
 
```
示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 解析1：
遍历链表，将每一个遍历的结点加入到hash表的中，然后判断新结点是否在Hash表中，如果在则环的入口，不在则返回空。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|96.46%|
|空间|$O(n)$|18.7 MB|7.69%|


```python
class Solution(object):
    def detectCycle(self, head):
        node = set()
        
        while head:
            if head in node:
                return head
            node.add(head)
            head = head.next
        return 
```


### 题目：

给定一个二叉树，返回它的 前序 遍历。

```
示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

### 解析1：
依然是递归解法，写起啦较简单。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|36 ms|35.62%|
|空间|$O(n)$|11.9 MB|11.43%|

```python
class Solution(object):
    def preorderTraversal(self, root):
        res = []
        def dfs(root):
            if not root:
                return None
            res.append(root.val)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return res
```

### 解析2：
迭代实现。使用栈保存每一个结点，依次保存右结点和左结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|28 ms|35.62%|
|空间|$O(n)$|11.7MB|32.69%|

步骤：
1. 栈保存根节点；
2. 遍历根结点：
   1. pop最新结点，然后保存结点值；
   2. 如果右子树不为空，右结点入栈；
   3. 如果左子树不为空，左结点入栈；

```python
class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return None
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)      
        return res
```
### 题目：
给定一个二叉树，返回它的 后序 遍历。
```
示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|28 ms|35.62%|
|空间|$O(n)$|11.7MB|32.69%|

### 解析1：
递归实现，对于递归而言，只是res的位置不同。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|35.62%|
|空间|$O(n)$|11.7MB|32.69%|


```python
class Solution(object):
    def postorderTraversal(self, root):
        res = []
        def dfs(root):
            if not root:
                return None
            dfs(root.left)
            dfs(root.right)
            res.append(root.val)
        dfs(root)
        
        return res
```

### 解析2：
循环实现，和前序遍历的不同依然是连接val的位置不同。有点迷这个解法。

```python
class Solution(object):
    def postorderTraversal(self, root):
        if not root:
            return []
        
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
            res.append(node.val)
        return res[::-1]        
```


### 题目：
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

```
示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

### 解析1：
使用有序字典实现，Collections.OrderedDict()。get，最近使用过的key，移动到末尾。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|248 ms|67.94%|
|空间|$O(n)$|22.8 MB|5.64%|

```python
import collections
class LRUCache:
    def __init__(self, capacity: int):
        self.dic = collections.OrderedDict()
        self.cap = capacity

    def get(self, key: int) -> int:
        if key not in self.dic:
            return -1
        self.dic.move_to_end(key)
        return self.dic[key]

    def put(self, key: int, value: int) -> None:
        if key in self.dic:
            del self.dic[key]
        
        if len(self.dic) >= self.cap:
            self.dic.popitem(0)
        
        self.dic[key] = value
```

### 有序字典OrderedDict:

### 题目：
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

```
示例 1:

输入: 4->2->1->3
输出: 1->2->3->4

示例 2:

输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

### 解析1：
将链表结点保存，然后排序，再重新生成链表。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|96ms|96.18%|
|空间|$O(n)$|37 MB|10.72%|

```python
class Solution(object):
    def sortList(self, head):
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
        
        res = node = ListNode(0)
        for num in sorted(nums):
            node.next = ListNode(num)
            node = node.next
        return res.next
```
### 题目：
给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

### 解析1：
暴力法，遍历每一个子序列，然后求乘积。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时| |
|空间|$O(1)$| | |

```python
class Solution(object):
    def maxProduct(self, A):
        res = float('-inf')
        length = len(A)
        for i in range(length):      
            for j in range(i+1, length+1):
                temp = 1
                for k in range(i, j):
                    temp *= A[k]      
                res = max(res, temp)
        return res
```

### 解析2：
动态规划，借助最大最小值，fmax(i)以i为结尾的连续子序列的最大值，fmin(i)连续子序列最小值。主要是下列状态转移方程。
```
fmax(i) = max(fmax(i-1)*num[i], fmin(i-1)*num[i], num[i])
fmin(i) = min(fmax(i-1)*num[i], fmin(i-1)*num[i], num[i])
```

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|80 ms| 55.76%|
|空间|$O(1)$|14.1 MB | 28.65%|


```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        pre_max = nums[0]
        pre_min = nums[0]
        for num in nums[1:]:
            cur_max = max(pre_max * num, pre_min * num, num)
            cur_min = min(pre_max * num, pre_min * num, num)
            res = max(res, cur_max)
            pre_max = cur_max
            pre_min = cur_min
        return res
```
### 题目：
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

>示例 1:
输入: [3,4,5,1,2]
输出: 1

### 解析1：
* **算法流程：**
  * 1. 比较nums[mid]和nums[right]，nums[mid]>nums[right],在右半区间，所以left = mid + 1
  * 2. if nums[mid] < nums[right]，在左半区间，right=mid
  * 3. left和right相等时停止，left和right均在旋转结点处；

* **复杂度：**

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|40 ms|87.70%|
|空间|$O(1)$|13.2 MB|33.01%|

Leetcode不需要考虑重复值，相比剑指offer简单了点。
```python
class Solution:
    def findMin(self, nums: [int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]: left = mid + 1
            else: right = mid
        return nums[left] 
```

### 解析2：
* **算法流程：**
  * 1. 如果nums[0] < nums[n-1]，最小值是nums[0]，未旋转；
  * 2. left从0，right从n-1开始二分查找；
  * 3. if nums[mid] > nums[left]:left = mid;
  * 4. if nums[mid] < nums[left]:right = mid;
  * 5. if nums[mid] > nums[mid+1],mid+1是最小值；
  * 5. is nums[mid-1] > nums[mid],mid是最小值

* **复杂度：**

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|40 ms|100%|
|空间|$O(1)$|13.4 MB|100%|

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if not nums:return -1
        n = len(nums)
        if n == 1:return nums[0]
        
        if nums[0] < nums[n-1]:return nums[0]
        left,right = 0,n-1
        while left <= right:
            mid = (left + right)//2
            if nums[mid-1]>nums[mid]:
                return nums[mid]
            if nums[mid]>nums[mid+1]:
                return nums[mid+1]
            if nums[mid] > nums[left]:
                left = mid
            if nums[mid] < nums[left]:
                right = mid
```
### 题目：
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

>示例 1：
输入: [1,3,5]
输出: 1

### 解析1：
偷懒性做法。
```python
class Solution(object):
    # O(n)
    def findMin(self, nums):

        if nums == []:
            return -1
        res = nums[0]
        for num in nums:
            res = min(res, num)
        return res

    def findMin(self, nums):
        return min(nums)
```

### 解析2：
《剑指offer》原题，只是需要考虑重复数字。

时间：O(logn)

```python
class Solution(object):
    def findMin(self, nums):
        if len(nums) == 0:
            return -1

        left = 0
        right = len(nums)-1
        if nums[left] < nums[right]:
            return nums[left]
        while left < right -1:
        # 由于重复元素的存在，需要考虑相等的情况
            mid = (left+right)//2
            if nums[mid] == nums[left] == nums[right]:
                return min(nums[left:right+1])
            if nums[mid] >= nums[left]:
                left = mid
            if nums[mid] <= nums[right]:
                right = mid
        return nums[right]
```

### 解析3：

* **算法流程：**
  * 1. 比较nums[mid]和nums[right]，nums[mid]>nums[right],在右半区间，所以left = mid + 1
  * 2. if nums[mid] < nums[right]，在左半区间，right=mid
  * 3. if nums[mid] == nums[right]，不能判断在左还是右区间，令right -= 1，不会漏掉最小值，同时更新指针
  * 4. left和right相等时停止，left和right均在旋转结点处；

* **算法复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|68 ms|34.42%|
|空间|$O(1)$|13.5 MB|38.48%|

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left,right = 0,len(nums)-1
        while left < right:
            mid = (left + right)//2
            if nums[mid] > nums[right]:left = mid + 1  # 此时mid肯定不是最小值
            elif nums[mid] < nums[right]:right = mid   # mid仍然可能是最小值
            else:right -= 1
        return nums[left]
```

### 题目：
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。

>示例:
MinStack MinStack = new MinStack();
MinStack.push(-2);
MinStack.push(0);
MinStack.push(-3);
MinStack.getMin();   --> 返回 -3.
MinStack.pop();
MinStack.top();      --> 返回 0.
MinStack.getMin();   --> 返回 -2.

### 解析1：
建立一个辅助栈，每次将已经压入栈内的最小值压入辅助栈。

* **算法流程：**
1. 主要是push的时候，如果辅助栈为空或者新元素小于辅助栈顶元素的时候push新元素，否则push辅助栈顶元素；
2. pop两个栈均pop，注意栈为空的情况

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|116 ms|31.87%|
|空间|$O(1)$|16.9 MB|100%|

```python
class MinStack(object):
    def __init__(self):
        self.stack = []
        self.MinStack = []
        
    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        self.stack.append(x)
        if self.MinStack == [] or x < self.MinStack[-1]:
            self.MinStack.append(x)
        else:
            self.MinStack.append(self.MinStack[-1])     
        
    def pop(self):
        # write code here
        if self.stack == None or self.MinStack == None:
            return None
        self.MinStack.pop()
        self.stack.pop()
        
    def top(self):
        # write code here
        return self.stack[-1]
        
    def getMin(self):
        # write code here
        return self.MinStack[-1]
```

### 题目：
编写一个程序，找到两个单链表相交的起始节点。
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

### 解析1：
由于是单链表，如果出现相交链表的话，后面的肯定都是相同。所以只需找到第一个相同的结点即可。

步骤:
1. 求两个链表的长度差k，然后让长的链表先走k步，直到两个链表长度相同为止。
2. 同时遍历两个链表结点：
   1. 两个链表一直走，直到出现链表结点相同为止；
   2. 输出最终的链表值；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(m+n)$|368 ms|9.76%|
|空间|$O(1)$|41.7 MB|36.31%|

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        def lenlist(node):
            res = 0
            while node:
                res += 1
                node = node.next
            return res
        lenA = lenlist(headA)
        lenB = lenlist(headB)
        if lenA < lenB:
            headA,headB = headB,headA
    
        diff = abs(lenA - lenB)
        for _ in range(diff):
            headA = headA.next

        while headA and headB and headB != headA:
            headA = headA.next
            headB = headB.next
        return headA
```

### 解析2：
思想是一样的，但是实现起来简单得多。目标依然是求解长度差，但是将两个链表拼接起来，pA = headA + headB,pB = headB + headA。遍历pA和pB，当结点值相等时，得到便是交点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(m+n)$|340 ms|19.76%|
|空间|$O(1)$|41.7 MB|31.31%|

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        pA,pB = headA,headB
        while pA != pB:
            pA = pA.next if pA else headB
            pB = pB.next if pB else headA
        return pA
```

详细原理：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/
### 题目：
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
```
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

### 解析1：
和第一题一样，采用相同的方式，将数值和索引作为key和value保存在字典中。遍历数组，然后跑判断差是否在字典中出现过，同时判断索引是否一致。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|96 ms|60.50%|
|空间|$O(n)$|14.2 MB|5.22%|

```python
class Solution:
    def twoSum(self, nums, target):
        nums_dict = dict()
        for index in range(len(nums)):
            if nums[index] not in nums_dict:
                nums_dict[nums[index]] = index
            temp = target-nums[index]
            if temp in nums_dict and nums_dict[temp] != index:
                return sorted([index+1,nums_dict[temp]+1])
```

### 解析2：
双指针。左右指针，分别编列，然后判断，收缩。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|96 ms|60.50%|
|空间|$O(n)$|14.2 MB|5.22%|

```python
class Solution:
    def twoSum(self, nums, target):
        left = 0
        right = len(nums)-1
        while left < right:
            temp = nums[left] + nums[right]
            if temp == target:
                return [left+1, right+1]
            elif temp < target:
                left += 1
            elif temp > target:
                right -= 1
        return [-1,-1]
```
### 题目：
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

输入: [3,2,3]
输出: 3

### 解析1：
* **算法流程：**
排序后众数如果存在肯定是中间那个数，所以先排序然后直接输出中间那个数。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(nlogn)$|44 ms|98.18%|
|空间|$O(1)$|15.1 MB|25.31%|

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums)//2]   
```

### 解析2：
哈希表保存每个数出现的次数，然后判断出现次数是否超过一半。确认是否一定存在众数，如果不存在的话返回什么。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|212 ms|44.90%|
|空间|$O(1)$|14.4 MB|5.04%|

```python
class Solution(object):
    def majorityElement(self, nums):
        num_cnt = {}
        for i in range(len(nums)):
            num_cnt[nums[i]] = num_cnt.get(nums[i], 0)+1
        
        for key,value in num_cnt.items():
            if value > len(nums)//2:
                return key
```

### 解析3：
函数库实现，Python就要足够骚。思路和上述一样。竟然不如自己实现的快。看来还是不要用库。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|60 ms|92%|
|空间|$O(1)$|14.4 MB|5.04%|

```python
class Solution:
    def majorityElement(self, nums):
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)
```

### 解析4：

摩尔投票法，设置两个变量candiate和count如果数字与之前的candiate相同则count+1，否则-1.count变成0以后更新candiate然后count变成1.

* **算法流程：**
  * 遍历数组，设置一个候选值，以及一个数来计算众数和非众数的计数差；
  * 假设当前数是众数，如果和候选值相同，cnt+1，否则-1；
  * 如果cnt变成0，则众数和非众数数量相同，看下一个候选值；


* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(nlogn)$|44 ms|98.18%|
|空间|$O(1)$|15MB|30.31%|

```python
class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```
### 题目：
给定一个Excel表格中的列名称，返回其相应的列序号。
```
例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
示例 1:

输入: "A"
输出: 1
示例 2:

输入: "AB"
输出: 28
```

### 解析1：
26进制转化成10进制，和进制转化一样，正常操作即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|99.9%|
|空间|$O(n)$|14 MB|6.10%|

```python
class Solution:
    def titleToNumber(self, s: str) -> int:
        res = 0
        temp = 1
        for c in s[::-1]:
            res += (ord(c)-64)*temp
            temp = temp*26
        return res
```

对代码进行简化。
```python
class Solution:
    def titleToNumber(self, s: str) -> int:
        return sum( (ord(a) - 64) * (26 ** i)  for i, a in enumerate(s[::-1]))
```
### 题目：
给定一个整数 n，返回 n! 结果尾数中零的数量。
```
示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

### 解析1：
求阶乘的每个元素有多少个因子是2和5，最后0的个数就是2和5因子数的最小值。但是超时啦。

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        two = 0
        five = 0
        for i in range(1,n+1):
            while i%2 == 0 or i%5 == 0:
                if i%2 == 0:
                    two += 1
                    i = i//2
                if i %5 == 0:
                    five += 1
                    i = i // 5
        return min(two,five)
```

### 解析2：
得到阶乘后的结果，然后求尾部有多少个0，但是依然超时了。

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        res = 1
        for i in range(1,n+1):
            res *= i
        cnt = 0
        for c in str(res)[::-1]:
            if c == '0':
                cnt += 1
            else:
                break
        return cnt
```

### 解析3：
求5的个数，求一共有多少个。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|44 ms|86.77%|
|空间|$O(n)$|13.8 MB|5.19%|


```python
class Solution(object):
    def trailingZeroes(self, n):
        ans = 0
        while n>=5:
            n //= 5
            ans += n
        return ans
```
### 题目：
给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。
```
示例 1:

输入: [10,2]
输出: 210
示例 2:

输入: [3,30,34,5,9]
输出: 9534330
```

### 解析1：
创建一种排序规则，两个数拼接，选择较大的那种情况。主要是排序规则的书写。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|99.19%|
|空间|$O(n)$|13.7 MB|5.11%|

```python
class LargerNumKey(str):
    def __lt__(x, y):
        return x+y > y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))
        # 如果是多个0的话只需返回一个0即可
        return '0' if largest_num[0] == '0' else largest_num
```
### 解析2：
通过functools实现，逻辑和上述差不多，只是排序规则的写法不同。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|99.19%|
|空间|$O(n)$|13.7 MB|5.11%|

```python
from functools import cmp_to_key

def helper(x,y):
    if x + y > y +x:return -1
    elif x + y < y + x :return 1
    else:return 0
        
class Solution:
    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=cmp_to_key(helper)))
        return '0' if largest_num[0] == '0' else largest_num
```

### Python排序：
记录关于Python排序相关的内容。

```python
# 1.按照字符长度排序：
sorted(["adf", "Adfdg", "aDfgbdfafg", "Gahgfh"], key = len)

# 2.按照小写字母排序：
sorted(["adf", "Adfdg", "aDfgbdfafg", "Gahgfh"], key = str.lower)

# 3.按照拼接后的先后顺序排序：自定义排序规则
## 3.1 自定义类
class LargerNumKey(str):
    def __lt__(x, y):
        return x+y > y+x
sorted(map(str, nums), key=LargerNumKey)

## 3.2 使用functools：
### 比较规则：
# 1. 如果x，y保持原顺序，返回 -1；
# 2. 如果x，y需要交换顺序，返回 1；
# 3.如果 x和y不需要交换顺序，返回 0

from functools import cmp_to_key
def helper(x, y):
    if x + y > y + x:
        return -1
    elif x + y < y + x:
        return 1
    else:
        return 0
sorted(map(str, nums), key=cmp_to_key(helper)

# 4.按照绝对值排序：
sorted(nums, key=abs)

# 5.二维数组，按照某个元素排序：
student_tuples = [
    ['john', 'A', 15],
    ['jane', 'B', 12],
    ['dave', 'B', 10],
]
sorted(student_tuples, key=lambda student: student[2])

# 6.使用operator模块
from operator import itemgetter, attrgetter
sorted(student_tuples, key=itemgetter(2))
# 控制排序优先级
sorted(student_tuples, key=itemgetter(1,2))

# 7.所有的小写字母在大写字母前面，所有的字母在数字前面，所有的奇数在偶数前面；
sorted(s, key=lambda x: (x.isdigit(), x.isdigit() and int(x) % 2 == 0, x.isupper(), x.islower(), x))
```
### 题目:
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
```
示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

### 解析1：
简单，直接旋转。要原地操作，注意如何写。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|72 ms|91.24%|
|空间|$O(n)$|15.1 MB|5.18%|

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        k = k%len(nums)
        nums[:] = nums[-k:] + nums[:-k]
```
### 题目：
颠倒给定的 32 位无符号整数的二进制位。

```
示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
### 解析1：
* **算法流程：**
  * bin(n):二进制表示
  * str.zfill(n)：字符串填充，在左边用0补全；
  * [::-1]：翻转
  * int：转换成十进制


* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|81%|
|空间|$O(n)$|13.6 MB|16%|


```python
class Solution:
    def reverseBits(self, n: int) -> int:
        return int(bin(n)[2:].zfill(32)[::-1],base=2)
```

### 二进制的python语法：
* bin(x)：返回数x的二进制表示；
* x^y：两个十进制的数对应的二进制位做异或；

### 题目：
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

```
示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

### 解析1：
转变成二进制然后直接返回，利用了python的内部机制，这个操作太骚了。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|65.73%|
|空间|$O(n)$|11.7 MB|36.16%|

```python
class Solution(object):
    def hammingWeight(self, n):
        return bin(n).count('1')
```

### 解析2：
* **算法流程：**
通过位运算来判断有多少个1，明显更费时。将x和1与，如果不是1，则n的二进制的最右边一位不是0，然后向右移位依次判断最右边是否是1即可。复杂度还是$O(n)$但是每次需要判断是否是1，还是很费时的。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|36 ms|11.38%|
|空间|$O(n)$|11.7 MB|36.16%|

```python
class Solution(object):
    def hammingWeight(self, n):
        count = 0
        while n:
            count += n&1
            n >>= 1
        return count
```


### 题目：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

>示例 1:
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 


### 解析1：
动态规划，主要是得到状态转移方程，如果直接得到比较麻烦，就从0开始推导，如下：
设$f(n)$为从前n个房子中抢到的最大数额；
* n=1:$f(1) = nums[0]$
* n=2:$f(2) = max(nums[0], nums[1])$
* n=3:$f(3) = max(f(1)+nums[2], f(2))$，两个选择，抢还是不抢第三个房子，如果抢则是$f(1)+nums[2]$，不抢则是$f(2)$，然后比较二者的大小

由此便可得到动态规划的状态转移方程： $f(n) = max(f(n-1), f(n-2)+nums[n])$。

动态规划的题目，主要是得到状态转移方程和状态含义，目前常见的两种，前n个数中的最优解，以第n个数为结尾的最优解。

可以用一个list保存对应的最大值，但是仅用两个数表示$f(n-1),f(n-2)$即可。初始化前两个数为0可以简化操作。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|28 ms| 43.76%|
|空间|$O(1)$|11.7 MB | 28.65%|

```python
class Solution(object):
    def rob(self, nums):
        a,b,length = 0,0,len(nums)
        for i in range(length):
            a,b = b, max(a+nums[i], b)
        return b
```



### 题目：
给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

```
示例 1:

输入:
11110
11010
11000
00000

输出: 1
示例 2:

输入:
11000
11000
00100
00011

输出: 3
```

### 解析1：
dfs，遍历每一个点，如果是1，令其周围的1都变成0（同一个岛屿），让1周围的1都变成0以后，不和这个1直接相邻的点才不会被改变，也就是下一个岛屿。

* **算法流程：**
  1. 遍历每一个点，如果该点值为1，计数+1，对他周围的点进行回溯，将周围的1都变成0，
  2. 将每一个回溯经过的1变成0，另一个岛屿由于不是接壤的所以不会被改变成0

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|168 ms|79.90%|
|空间|$O(mn)$|15.2 MB|14.65%|


```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        n = len(grid)
        if not n:return 0
        m = len(grid[0])
        def helper(i,j):
            grid[i][j] = '0'
            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:
                nx,ny = i+dx,j+dy
                if 0<=nx<n and 0<=ny<m and grid[nx][ny] == '1':
                    helper(nx,ny)
        res = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == '1':
                    res += 1
                    helper(i,j)
        return res

```
### 题目：
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

```
示例 1: 

输入: [5,7]
输出: 4
```

### 解析1：
直接按照题意，进行按位与，超时超内存。

```python
class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        res = m
        for i in range(m+1,n+1):
            res = res & i
        return res
```

### 解析2：
如果有一位出现0，那么这个位数相与都是0，则可以直接判断m和n，第一位不相等的数，从那个数开始后面相与都变成0，然后再反向（向左）移位。具体解释起来有点麻烦，可以看解析：https://cloud.tencent.com/developer/article/1350057

n:二进制位数
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|72 ms|31.09%|
|空间|$O(n)$|11.8 MB|12.50%|

```python
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        t = 0
        while m != n:
            m >>= 1
            n >>= 1
            t += 1
        return n << t
```

### 题目：
编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。
```
示例: 

输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

### 解析1：
用规律求解，在不知道的情况下，是比较麻烦的。这里面有一个规律。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|44 ms|96.54%|
|空间|$O(n)$|13.8 MB|5.56%|


**规律:**
1. [1,4]之间的数只有1是快乐数，其他均不是，3和4会进入一个循环序列；
2. [4,+无穷]非快乐数会进入3,4的循环，快乐数会得到1；


```python
class Solution:
    def isHappy(self, n: int) -> bool:
        return self.isHappy(sum([int(x)**2 for x in str(n)])) if n > 4 else n == 1
```

### 题目：
统计所有小于非负整数 n 的质数的数量。

示例:

输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

### 解析1：
常规超时做法，遍历每一个数，然后看起是否是质数。

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        res = 0
        for i in range(2, n):
            for j in range(2, i):
                if i % j == 0:
                    break
            else:
                #print(i)
                res += 1
        return res
```

### 解析2：
设置一个质数数组，从2开始，2是质数True，那么2的倍数均不是质数，令2的所有倍数为False，继续遍历，得到一个质数数组。
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        isPrimes = [1] * n
        res = 0
        for i in range(2, n):
            if isPrimes[i] == 1: res += 1
            j = i
            while i * j < n:
                isPrimes[i * j] = 0
                j += 1
        return res
```

优化后的版本：
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 2: return 0
        isPrimes = [1] * n
        isPrimes[0] = isPrimes[1] = 0
        for i in range(2, int(n ** 0.5) + 1):
            if isPrimes[i] == 1:
                isPrimes[i * i: n: i] = [0] * len(isPrimes[i * i: n: i])
        return sum(isPrimes)
```
### 题目：
反转一个单链表。

>示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

### 解析1：
对原始链表的处理。循环简单求解。
* **算法流程：**
  * 1. None赋值给res（目标链表）
  * 2. 遍历原链表
  * 3. 保存原链表结点值的next
  * 4. 原链表当前结点的next，指向res；
  * 5. 当前结点赋值给res；
  * 6. 原链表结点的next，赋值给当前结点


* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|91.65%|
|空间|$O(n)$|13.5 MB|46.06%|

```python
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead is None:
            return pHead
        last = None  #指向上一个节点
        while pHead:
            # 先用tmp保存pHead的下一个节点的信息，
            # 保证单链表不会因为失去pHead节点的next而就此断裂
            tmp = pHead.next
            # 保存完next，就可以让pHead的next指向last了
            pHead.next = last
            # pHead赋值给last
            last = pHead
            # 对pHead进行更新，获取下一个结点
            pHead = tmp
        return last
```

上述代码利用了python的特性，赋值的时候不用考虑先后的问题。下面用temp保存pHead.next结点。
```python
class Solution(object):
    def reverseList(self, head):
        res = None
        while head:res,res.next, head = head, res, head.next
        return res
```

### 解析2：
递归求解。

```python
class Solution:
    def ReverseList(self, pHead):
        # write code here
        if not pHead or not pHead.next:
            return pHead
        else:
            newHead = self.ReverseList(pHead.next)
            pHead.next.next=pHead
            pHead.next=None
            return newHead
```
### 题目：
现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

```
示例 1:

输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
示例 2:

输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

### 解析1：
拓扑排序，每一次从图中删除入度为0的点，即这些点不需要前修课。删除该节点，然后令和此结点相连的结点的入度-1。如果入度为0即进入队列，最后判断队列的大小和numCourse的大小。

E:边数，V:结点数
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(E+V)$|264 ms|22.52%|
|空间|$O(V)$|15 MB|35.00%|


```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 统计入度数
        indegrees = [0 for _ in range(numCourses)]
        # 邻接表
        adjacency = [[] for _ in range(numCourses)]
        queue = []
        # Get the indegree and adjacency of every course.
        for cur, pre in prerequisites:
            # 统计入度，后面一个点是要求必修的课，统计前面的点入度
            indegrees[cur] += 1
            # 邻接表：统计每个点指向的课程结点
            adjacency[pre].append(cur)

        # 统计入度为0的点，这些课程不需要先修课，所以可以直接放入queue中
        for i in range(len(indegrees)):
            if not indegrees[i]: queue.append(i)
        
        # 依次将queue中的点出队，然后将它所连的课程结点入度-1；
        while queue:
            pre = queue.pop(0)
            numCourses -= 1
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]: queue.append(cur)
        return not numCourses
```
### 题目：
实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
```
示例:

Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

### 解析1：
emmm很直男的做法，直接进行求解的，判断是否在一个set里面，前缀也可以同样比较。没有使用数据结构，时间效率明显很低。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|1388 ms|5.23%|
|空间|$O(1)$|20.2 MB|92.83%|

```python
class Trie:

    def __init__(self):
        self.set = set()

    def insert(self, word: str) -> None:
        self.set.add(word)
        
    def search(self, word: str) -> bool:
        return word in self.set       

    def startsWith(self, prefix: str) -> bool:
        for word in self.set:
            if prefix == word[:len(prefix)]:
                return True
        return False
```
### 题目：
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```
>示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

### 解析1：
排序，然后返回倒数第k个元素。普通排序的方法。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|96 ms|74.52%|
|空间|$O(n)$|14.9MB|19.21%|

```python
class Solution(object):
    def findKthLargest(self, nums, k):
        return sorted(nums)[-k]
```

### 解析2：
保留前k个值在数组中，遍历剩下的元素，如果元素大于数组的最小值则替换掉他。最后得到最大的k个数。返回最大k个数这个数组中最小的数，即为第k大的数。部分排序，

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nk)$|360 ms|37.01%|
|空间|$O(k)$|12.4 MB|29.36%|

步骤：
1. 建立一个list数组保存最大的k个数；
2. 遍历数组，如果大于数组中最小的数，则去掉最小的数，插入当前数；
3. 返回list中最小的数；

```python
class Solution(object):
    def findKthLargest(self, nums, k):
        if k > len(nums):
            return -1
        res = nums[:k]
        for i in range(k, len(nums)):
            min_num = min(res)
            if nums[i] >= min_num:
                res.remove(min_num)
                res.append(nums[i])
        return min(res)
```

### 解析3：
思路是相同的通过python自带的优先队列库实现。

时间：O(nlogk)
空间：O(k)

步骤：
1. 最小堆保存前k个数；
2. 遍历k后面的数；
3. 如果当前数小于最小堆堆顶的数（最小值），则替换最小值；

```python
import heapq
class Solution:
    def findKthLargest(self, nums, k):
        if k > len(nums):
            return -1
        heap = []
        for i in range(k):
            heapq.heappush(heap, nums[i])
        for i in range(k, len(nums)):
            if nums[i] > heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, nums[i])
        return heap[0]
```

再次优化：这种实现效果更好。

```python
import heapq
class Solution:
    def findKthLargest(self, nums, k):
        if len(nums) < k:
            return -1
        heap = []
        for i in range(k):
            heapq.heappush(heap, nums[i])
        for i in range(k, len(nums)):
        # 其实就是push完k个元素后，后面不断执行push，pop的操作
            heapq.heappushpop(heap, nums[i])
        return heap[0]
```

对上述代码再次优化，优化循环部分：
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogk)$|84 ms|65.74%|
|空间|$O(n)$|12.4 MB|26.54%|

```python
import heapq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        res = []
        if k > n:return -1
        for i in range(n):
            if i < k:heapq.heappush(res, nums[i])
            else:heapq.heappushpop(res, nums[i])
        return res[0]
```

优化到最简，但是效率并不能保证。
```python
class Solution:
    def findKthLargest(self, nums, k):
    # 返回最大的k个数
        if k > len(nums):
            return -1
        return heapq.nlargest(k, nums)[-1]
```


### 堆队列：
此类问题均需要使用堆的方法来实现，所以对python的heapq进行以下总结。heapq实现的是一个最小堆，也就是堆顶为堆的最小值。此类问题一般有两种情况，求第k个（前k个）最大的元素和第k个（前k个）最小的元素。

* 第k个最大的元素，维护最小堆，判断新元素是否大于堆顶，大于则替换；最终堆顶返回第k个最大的元素，堆内为前k个最大的元素；
* 第k个最小的元素，维护最大堆，判断新元素是否小于堆顶，小于则替换；最终堆顶返回第k个最小的元素，堆内为前k个最小的元素；

```python
import heapq
heap = []

item = 10
# 将 item 的值加入 heap 中，保持堆的不变性
heapq.heappush(heap, item)

# 弹出并返回 heap 的最小的元素，保持堆的不变性
item = heapq.heappop(heap)
# 只访问最小的元素而不弹出
item = heap[0]

# 将item放入堆中，然后弹出并返回 heap 的最小元素,比先调用 heappush()再调用heappop()更有效率
item = heapq.headpushpop(heap, item)

# 将list转换成堆，线性时间
heapq.heapify(x)

# 返回n个最大的数
heapq.nlargest(n, heap)
# 返回n个最小的数
heapq.nsmallest(n, heap)
```


### 题目：
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 

```
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

### 解析1：
依然是回溯法，可使用万能模板，和其他没什么两样。加一个判断条件，判断n是否为0以及temp长度是否是k。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O()$|32 ms|35.23%|
|空间|$O(1)$|11.8 MB|30.66%|

```python
class Solution(object):
    def combinationSum3(self, k, n):
        res = []
        nums = list(range(1, 10))
        
        def backtrack(nums, temp, n):
            if n == 0 and len(temp) == k:
                res.append(temp)
            else:
                for i in range(len(nums)):
                    backtrack(nums[i+1:], temp+[nums[i]], n-nums[i])
        
        backtrack(nums, [], n)
        return res   
```
### 题目：
给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

```
示例 1:

输入: [1,2,3,1]
输出: true
```

### 解析1：
暴力法比较每一个数值对，如果出现两个数相同则返回True，否则False。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(1)$|||

```python
class Solution(object):
    def containsDuplicate(self, nums):
        n = len(nums)
        for i in range(n-1):
            for j in range(i+1, n):
                if nums[i] == nums[j]:
                    return True
        return False
```

### 解析2：
先排序，排序后如果两个数相同，那么他们应该是相邻的，判断相邻元素是否相等，如果相等则返回True。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|148 ms|45.64%|
|空间|$O(1)$|16 MB|38.07%|

```python
class Solution(object):
    def containsDuplicate(self, nums):
        n = len(nums)
        nums = sorted(nums)
        for i in range(n-1):
            if nums[i] == nums[i+1]:
                return True
        return False
```

### 解析3：
采用哈希表保存每个数出现的次数。哈希表的时间复杂度，search和insert的平均时间复杂度均为 O(1)O(1)。虽然复杂度是O(n)，但是时间并不短。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|192 ms|13.81%|
|空间|$O(n)$|17 MB|35.05%|

```python
class Solution(object):
    def containsDuplicate(self, nums):
        cnt_dict = {}
        for num in nums:
            cnt_dict[num] = cnt_dict.get(num ,0) + 1
        for key,value in cnt_dict.items():
            if value >= 2:
                return True
        return False
```

### 解析4：
同样哈希表实现，对于判断性任务，首先判断是否在哈希表中出现过，如果没有出现过添加到哈希表里面，这样能降低复杂度。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|152 ms|33.81%|
|空间|$O(n)$|17 MB|35.05%|

```python
class Solution(object):
    def containsDuplicate(self, nums):
        cnt = set()
        for num in nums:
            if num in cnt:return True
            cnt.add(num)
        return False
```

### 解析5：
集合法，求set后，判断set(nums)和nums是否长度相同。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|136 ms|89.35%|
|空间|$O(n)$|17.2 MB|26.19%|

```python
class Solution(object):
    def containsDuplicate(self, nums):
        return len((set(nums))) != len(nums)
```
### 题目：
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

```
示例 1:

输入: nums = [1,2,3,1], k = 3
输出: true
```

### 解析1：
哈希表存储每个数出现的位置，判断是否在哈希表中出现过，同时判断索引是否满足条件。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|136 ms|19.91%|
|空间|$O(n)$|16.7 MB|8.53%|

```python
class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        cnt = {}
        for i in range(len(nums)):
            if nums[i] in cnt and i - cnt[nums[i]] <= k:
                return True
            cnt[nums[i]] = i
        return False
```
### 题目：
给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。
```
示例 1:

输入: nums = [1,2,3,1], k = 3, t = 0
输出: true
```

### 解析1：
暴力法，遍历两边数组，然后判断是否满足大小和索引关系。直接超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n min(k,n))$|超时||
|空间|$O(1)$|||


```python
class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        n = len(nums)
        for i in range(n-1):
            for j in range(i+1, n):
                if abs(nums[i] - nums[j]) <= t and j-i <= k:
                    return True
        return False
```
简单优化依然超时：

```python
class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        cnt = {}
        n = len(nums)
        for i in range(n-1):
            j = i + 1
            while j < n and j < i+k+1:
                if abs(nums[i] - nums[j]) <= t:
                    return True
                j += 1
        return False
            
        
```
### 解析2：

桶排序，不太明白。

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        if t < 0: return False
        n = len(nums)
        d = {}
        w = t + 1
        for i in xrange(n):
            m = nums[i] / w
            if m in d:
                return True
            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:
                return True
            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:
                return True
            d[m] = nums[i]
            if i >= k: del d[nums[i - k] / w]
        return False
```

### 题目：
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
```
示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 解析1：
应用动态规划，但是为什么是判断matrix[i-1][j-1]是否是1呢，辅助矩阵的大小不是m* n吗，为什么(m+1)*(n+1)。重新描述下题目。

状态含义：dp[i][j] 对应matrix[i-1][j-1]是否，以[i-1,j-1]为左下角的正方形的最大边长。
转移方程：dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|184 ms|83.18%|
|空间|$O(mn)$|86.2 MB|26.87%|


```python
class Solution:
    def maximalSquare(self, matrix):
        if not matrix: return 0
        row = len(matrix)
        col = len(matrix[0])
        dp = [[0] * (col + 1) for _ in range(row + 1)]
        res = 0
        for i in range(1, row +1):
            for j in range(1, col + 1):
                if matrix[i - 1][j - 1] == "1":
                    dp[i][j] = min(dp[i-1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
                    res = max(res, dp[i][j])
        return res*res
```
### 题目：
使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

### 解析1：
作弊式：

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|20 ms|71.71%|
|空间|$O(n)$|11.9 MB|8.14%|

```python
class MyStack(object):

    def __init__(self):
        self.stack = []
        
    def push(self, x):
        self.stack.append(x)
        
    def pop(self):
        return self.stack.pop(-1)
        
    def top(self):
        return self.stack[-1]

    def empty(self):
        return len(self.stack) == 0
```

### 解析2：

* **算法思想：**
  * 1. push的时候，将前面的依次出队，然后依次再push到新元素的后面；
  * 2. pop的时候队列的第一个元素，即栈顶元素

* **复杂度：**

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$入队：O(n)$|28 ms|88.15%|
|空间|$O(n)$|13.1 MB|40.94%|

```python
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = []

    def push(self, x: int) -> None:
        """
        Push element x onto stack.复杂度 O(n),
        """
        self.queue.append(x)
        for i in range(len(self.queue)-1):self.queue.append(self.queue.pop(0))


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.pop(0)
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[0]

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
```
### 题目：
翻转一棵二叉树。
```
示例：

输入：
     4  
   /   \  
  2     7  
 / \   / \  
1   3 6   9  

输出：

     4
   /   \
  7     2 
 / \   / \
9   6 3   1
```
### 解析1：
递归直接翻转，判断树是否为空，如果为空返回None，不为空则翻转左右子树。然后递归调用，对左右子树。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|56.52%|
|空间|$O(n)$|13.9 MB|34.60%|


```python
class Solution(object):
    def invertTree(self, root):
        if root == None:
            return None
        root.left,root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

### 解析2；
Leetcode的评测时间简直就是随机数啊，太迷了。循环实现，用队列，依次保存树结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|96.52%|
|空间|$O(n)$|13.9 MB|5.24%|

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:return None
        queue = [root]
        while queue:
            temp = queue.pop(0)

            temp.left,temp.right = temp.right,temp.left
            if temp.left:queue.append(temp.left)
            if temp.right:queue.append(temp.right)
            
        return root
```
### 题目：
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。
```
示例 1:

输入: "3+2*2"
输出: 7
示例 2:

输入: " 3/2 "
输出: 1
示例 3:

输入: " 3+5 / 2 "
输出: 5
```

### 解析1：

### 题目：
给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]

### 解析1：
依然是统计次数，然后判断是否超过[n/3]。

```python
class Solution(object):
    def majorityElement(self, nums):
        num_cnt = {}
        for i in range(len(nums)):
            num_cnt[nums[i]] = num_cnt.get(nums[i], 0)+1
        res = []
        for key,value in num_cnt.items():
            if value > len(nums)//3:
                res.append(key)
        return res
```
### 题目：
给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
```
示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

### 解析1：
对二叉搜索树进行中序遍历，中序遍历得到的便是排序数组，然后返回第k个元素。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|73.50%|
|空间|$O(n)$|19.7 MB|13.13%|


```python
class Solution(object):
    def kthSmallest(self, root, k):
        res = []
        def dfs(root):
            if not root:
                return None
            
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return res[k-1]
```
### 题目：
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
```
示例 1:

输入: 1
输出: true
解释: 20 = 1
示例 2:

输入: 16
输出: true
解释: 24 = 16
```

### 解析1：
不断整除2，看最后是否能变成1，对于0和1分开单独判断一下。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|16ms|96.15%|
|空间|$O(n)$|11.8 MB|10.32%|

```python
class Solution(object):
    def isPowerOfTwo(self, n):
        if n == 0:return False
        if n == 1:return True
        
        while n != 1:
            if n % 2 == 0:n = n//2
            else:return False
        return True
```

### 解析2：
数学加幂运算，该用的都用上了。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & (n - 1) == 0
```

### 解析3：
统计这个数的二进制表示中，1的个数，如果是2的次幂那么只有一个1。

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n < 0:return False
        return bin(n).count('1') == 1
```

### 题目：
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```
示例:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```
说明:

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

### 解析1：
作弊式：

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|8 ms|98.93%|
|空间|$O(n)$|11.9 MB|8.14%|

```python
class MyQueue(object):

    def __init__(self):
        self.queue = []

    def push(self, x):
        self.queue.append(x)

    def pop(self):
        return self.queue.pop(0)

    def peek(self):
        return self.queue[0]

    def empty(self):
        return len(self.queue) == 0
```

### 解析2：
真正通过两个栈来实现队列，将一个栈的内容依次弹出，放入另外一个栈，另外一个栈作为辅助栈。模拟从将水从一个杯子倒入到另一个杯子的过程。peek和pop都需要类似的处理，只不过pop返回同时去除那个元素，peek返回即可。

* **算法思想：**
  * 1. 两个栈来代替队列，stack1用于保存正常的输入，stack1出栈然后保存在stack2中；
  * 2. 入队时，将val进入self.stack1即可
  * 3. 出队时，如果stack2不为空，首先将stack2出栈，如果stack2为空，将stack1全部出栈到stack2后，再对stack2出栈


* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|16 ms|91.62%|
|空间|$O(n)$|11.7 MB|26.65%|

```python
class MyQueue(object):

    def __init__(self):
        self.stack1 = []
        self.stack2 = []
        
    def push(self, x):
        self.stack1.append(x)

    def pop(self):
        if self.stack2 == []:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def peek(self):
        if self.stack2 == []:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        return self.stack2[-1]
        
    def empty(self):
        return self.stack1 == [] and self.stack2 == []
```
### 题目：
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true

### 解析1：
将链表保存成list，然后判断list是否是回文的。判断首尾是否相等即可。空间复杂度不符合要求。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|84 ms|63.87%|
|空间|$O(n)$|31.5 MB|7.96%|


```python
class Solution(object):
    def isPalindrome(self, head):
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return self.IsPali(res)
    
    def IsPali(self, nums):
        # return nums == nums[::-1]  # 简单写法
        n = len(nums)
        for i in range(n>>1):
            if nums[i] != nums[n-1-i]:
                return False
        return True
```

### 解析2：
利用快慢指针。

步骤：
1. 快慢指针，快指针走两步，慢指针走一步，快指针到末尾，慢指针到中点；
2. 翻转链表前半部分，或者翻转后半部分，由于获取到了中点结点的指针，所以可以各种比较。

### 题目：
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

```
示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

### 解析1：
和236题一样，二叉搜索树和二叉树同样的操作，直接寻找最小公共祖先。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|124 ms|33.94%|
|空间|$O(1)$|17.9 MB|5.48%|

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.res = None
        def dfs(node):
            if not node:return False
            left = dfs(node.left)
            right = dfs(node.right)
            
            mid = node == p or node == q
            if mid + left + right >= 2:
                self.res = node
            return mid or left or right
        
        dfs(root)
        return self.res
```

### 解析2：
二叉搜索树的特性：左 < 根 < 右；

* **算法流程：**
  * 1. 目的，从根结点开始，向下遍历，找到最先满足，p.val < root.val < q.val；
  * 2. 如果root.val大于两个结点值，则最近公共祖先在root.left；
  * 3. 如果root.val小于两个结点值，则最近公共祖先在root.right；
利用二叉搜索树的特性，根据pq的值，和根节点值，判断pq所在的范围。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|140 ms|13.54%|
|空间|$O(1)$|17.7 MB|19.48%|

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 如果根节点值大于q和p的值，则在左子树
        if root.val > q.val and root.val > p.val:
            return self.lowestCommonAncestor(root.left, p, q)
        # 如果根节点值小于q和p的值，则在右子树
        
        if root.val < q.val and root.val < p.val:
            return self.lowestCommonAncestor(root.right, p, q)
        # 否则最近公共祖先便是root
        return root
```


### 题目：
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

```
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

     3
   /   \
  5     1
 / \   / \
6  2  0   8
  / \
 7   4
```

### 解析1：
递归，依次判断结点值是否等于p或者q，维护两个变量left和right，判断p，q是否出现在左右子树中。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|76 ms|99.94%|
|空间|$O(1)$|28.7 MB|5.04%|

步骤：
1. 设置一个辅助函数，求以node为根节点的子树中，是否出现了p或者q；
2. 如果左子树，右子树和node超过两个为True，他便是最低公共祖先；

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.res = None
        def helper(node):
            if not node:return False
            left = helper(node.left)
            right = helper(node.right)
            
            mid = node == p or node == q
            if mid + left + right >= 2:
                self.res = node
            return mid or left or right
        helper(root)
        return self.res
```
### 题目：
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

```
示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

### 解析1：
题目有点迷，跳过当前点既可，val和next做好赋值。建议参考[面试题18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)，考察如何删除链表中结点。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|32 ms|69.48%|
|空间|$O(1)$|12.2 MB|34.26%|

```python
class Solution(object):
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```
### 题目：

给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

>示例:
输入: [1,2,3,4]
输出: [24,12,8,6]

### 解析1：
暴力，遍历两次数组。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时| |
|空间|$O(1)$| | |

```python
class Solution(object):
    def productExceptSelf(self, nums):
        res = []
        for i in range(len(nums)):
            temp = 1
            for j in range(len(nums)):
                if i == j:continue
                temp *= nums[j]
            res.append(temp)
        return res
```

### 解析2：
遍历两次数组，第一次正向累乘，将第k个数字前面的所有数字相乘保存在第k个数里面。反向相乘，将第k个数后面的累乘。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|196 ms|21.20%|
|空间|$O(1)$|18.5 MB|56.69% |

注意累乘的起始点，第一个和最后一个数不算在累乘里面。

```python
class Solution(object):
    def productExceptSelf(self, nums):
        length = len(nums)
        res = [1]*length
        for i in range(1, length):
            res[i] = nums[i-1]*res[i-1]
        temp = 1
        for i in range(length-2, -1,-1):
            temp *= nums[i+1]
            res[i] = temp * res[i]  
        return res
```
### 题目：
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

```
示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
```

### 解析1：
暴力法，滑动窗口遍历，每次求解窗口的最大值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nk)$|620 ms|17.10%|
|空间|$O(n-k)$|18.8 MB|27.66%|

```python
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        n = len(nums)
        if n*k == 0:
            return []
    
        return [max(nums[i:i+k]) for i in range(n-k+1)]
```
### 题目：
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
```
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false。
```

### 解析1：
原矩阵从左到右升序；从上到下升序。从右上到左下遍历。暴力遍历的方法简单在此不表。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(max(n,m))$|56 ms|86.65%|
|空间|$O(1)$|18.5 MB|5.18%|

```python
class Solution:
    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]:return False
        n,m = len(matrix),len(matrix[0])
        i,j = 0,m-1 
        while i < n and j >= 0:
            if matrix[i][j] == target:return True
            elif matrix[i][j] > target: j -= 1
            else: i += 1
        return False
```
### 题目：
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
```
示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
```

### 解析1：
统计每个字符出现的次数，然后判断两个哈希表是否相等。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|36 ms|100%|
|空间|$O(n)$|14.1 MB|22.38%|

```python
from collections import Counter
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```
### 题目：
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
```
示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]
```

### 解析1：
同样的套路，我佛了。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|60ms|75.9%|
|空间|$O(n)$|14.7 MB|5.32%|


```python
class Solution(object):
    def singleNumber(self, nums):
        cnt_dict = {}
        res = []
        for num in nums:
            cnt_dict[num] = cnt_dict.get(num, 0) + 1
        for key,value in cnt_dict.items():
            if value == 1:
                res.append(key)
        return res
```

再奉上一套。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|68ms|45.78|
|空间|$O(n)$|13.5 MB|15.32%|

```python
class Solution(object):
    def singleNumber(self, nums):
        num_set = set()
        for num in nums:
            if num not in num_set:
                num_set.add(num)
            else:
                num_set.remove(num)
        return list(num_set)
```
### 题目：
编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

示例 1:

输入: 6
输出: true
解释: 6 = 2 × 3
示例 2:

输入: 8
输出: true
解释: 8 = 2 × 2 × 2
示例 3:

输入: 14
输出: false 


### 解析1：
**算法流程：**
1. 不断除以2，3，5，判断是是否还有因子2，3，5；
2. 如果不能除以2，3，5，且不为1，则False，否则True

**复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O( )$|60 ms|9.76%|
|空间|$O(1)$|13.7 MB|5.31%|

```python
class Solution:
    def isUgly(self, num: int) -> bool:
        if num <= 0:return False
        while num not in set([1,2,3,5]):
            if num %2 == 0:num /= 2
            elif num % 3 == 0:num //= 3
            elif num % 5 == 0:num //= 5
            else:return False
        return True
```

进行一次优化，循环中如果num为1，返回True，如果因子没有2，3，5且不为1，那么返回False。

```python
class Solution:
    def isUgly(self, num: int) -> bool:
        if num <= 0:
            return False
        while True:
            if num %2 == 0:
                num /= 2
            elif num % 3 == 0:
                num /= 3
            elif num % 5 == 0:
                num /= 5
            elif num == 1:
                return True
            else:
                return False
```
### 题目：

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
```
示例 1:

输入: [3,0,1]
输出: 2
```

### 解析1：
数学法，确实的数字 = sum[0,1,2,..n] - sum(nums)。排序，哈希表等方法过于麻烦在此不表。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|148ms|94.26%|
|空间|$O(1)$|12.7 MB|13.35%|

```python
class Solution(object):
    def missingNumber(self, nums):
        n = len(nums)
        return n*(n+1)/2 - sum(nums)
```
### 题目：
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
```
示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

### 解析1：
动态规划，但是超时了。

状态含义：dp[i]和为i的最小完全平方数个数；
状态方程：dp[i] = min(dp[i], dp[i-num]+1) for num in nums  
nums为小于的i的完全平方数数组集合。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(n)$|||


```python
class Solution:
    def numSquares(self, n: int) -> int:
        squares = []
        for i in range(1,n):
            if i **2<=n:
                squares.append(i**2)
        dp = [n]*(n+1)
        dp[0] = 0
        for i in range(1,n+1):
            for num in squares:
                if i >= num:
                    dp[i] = min(dp[i], dp[i-num]+1)
                else:
                    break
        return dp[n]
```

### 解析2：
拉格朗日四平方数公式。

```python
class Solution:
    def numSquares(self, n: int) -> int:
        while n % 4 == 0:
            n /= 4
        if n % 8 == 7:
            return 4
        
        a = 0
        while a**2 <= n:
            b = int((n - a**2)**0.5)
            if a**2 + b**2 == n:
                return bool(a) + bool(b)
            a += 1
        
        return 3
```
### 题目：
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

### 解析1：
遇到0，remove，然后append。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|84 ms|63.87%|
|空间|$O(n)$|31.5 MB|7.96%|

```python
class Solution(object):
    def moveZeroes(self, nums):
        n = len(nums)
        for i in range(n):
            if nums[i] == 0:
                nums.remove(0)
                nums.append(0)
        return nums   
```

### 解析2：
遇到0依次向后排，如果遇到元素不是0，就和第一个0替换，将0替换到后面。快慢指针的思想。快指针依次遍历，数组，碰到不是0的元素就和慢指针替换。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|99.64%|
|空间|$O(1)$|12.7 MB|33.48%|


```python
class Solution(object):
    def moveZeroes(self, nums):
        j = 0
        for i in range(len(nums)):
            # j保存第一个0的位置，每次遇到不是0的元素，和第一个0进行替换
            if nums[i] != 0:
                nums[i], nums[j] = nums[j],nums[i]
                j += 1
```

### 解析3：
直接调用函数一行实现，很迷不知道为什么用sorted不行。

```python
class Solution(object):
    def moveZeroes(self, nums):
        # nums = sorted(nums, key=bool, reverse=True)
        nums.sort(key=bool, reverse=True)
```

### 题目：
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2

### 解析1：
暴力法的复杂度是$O(n^2)$，没有修改了原来的数组，但是空间复杂度不满足要求。   
依然是哈希表，保存在哈希表里面判断是否出现过新数。空间复杂度不满足要求。


|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|96 ms|26.96%|
|空间|$O(n)$|13.9 MB|8.92%|

```python
class Solution(object):
    def findDuplicate(self, nums):
        cnt = set()
        for num in nums:
            if num in cnt: return num
            cnt.add(num)
```

### 解析2：
排序然后判断相邻元素是否相同。修改了原数组，如果不修改数组，则空间复杂度不满足要求。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|108 ms|16.49%|
|空间|$O(n)$|13.6 MB|27.71%|

```python
class Solution:
    def findDuplicate(self, nums):
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1]:
                return nums[i]
```

### 解析3：
二分查找，很多讲解的文章其实没有讲解清楚。首先明确的是，我们在1-n，这n个数中查找，哪个数出现了两次，而不是在原数组中查找。通过不断缩小1-n的区间来缩小查找范围。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|68 ms|83.93%|
|空间|$O(n)$|13.7 MB|18.47%|

步骤：
1. 二分法遍历1-n:
   1. left，right，mid，遍历数组求有多少个数小于等于mid--cnt；
   2. 如果cnt <= mid，那么重复数在[mid+1,right]中,因为此时最多是出现mid个数小于等于mid也就是1-mid都被覆盖了，而且只有一个重复的整数；反之在[left, mid]中；

```python
class Solution:
    def findDuplicate(self, nums):
        left, right = 0,len(nums)-1
        while left < right:
            mid = (left + right)>>1
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return left
```
### 题目：
根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
```
示例:

输入: 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出: 
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```

### 解析1：
按照题意，进行判断比较。

```python
class Solution(object):
    def gameOfLife(self, board):
        if not board:return []
        m,n = len(board),len(board[0])
        
        flag = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
        res = [[0]*n for _ in range(m)]
        for i in range(m):
            temp = []
            for j in range(n):
                live = 0
                for x,y in flag:
                    n_i = i + x
                    n_j = j + y
                    if 0 <= n_i < m and 0 <= n_j < n and board[n_i][n_j] == 1:
                        live += 1

                if board[i][j] == 1:
                    if live == 2 or live == 3:res[i][j] = 1
                    else:res[i][j] = 0
                else:
                    if live == 3:res[i][j] = 1
                    else:res[i][j] = 0
        for i in range(m):
            for j in range(n):
                board[i][j] = res[i][j]
```
### 题目：
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
```
示例:

输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
```

### 解析1：
寻找规律，1,2,3先手肯定会赢，4的时候不管取多少个都会输，5,6,7都会赢。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|40 ms|94.59%|
|空间|$O(1)$|13.9 MB|5.37%|

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n%4 != 0
```
### 题目：
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

```
示例：

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

### 解析1：
添加数的时候直接放在末尾，获取中位数的时候，排序，然后返回中位数。直接超时。

```python
class MedianFinder(object):

    def __init__(self):
        self.nums = []

    def addNum(self, num):
        self.nums.append(num)
        

    def findMedian(self):
        self.nums.sort()
        n = len(self.nums)

        if n%2 == 0:
            return (self.nums[n//2-1] + self.nums[n//2])/2
        else:
            return (self.nums[n//2])
```

### 解析2：
二分插入排序，也就是直接得到排序的数组。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|264 ms|74.46%|
|空间|$O(n)$|24.8 MB|5.26%|

插入复杂度是$O(n)$。


```python
class MedianFinder(object):

    def __init__(self):
        self.nums = []

    def addNum(self, num):
        bisect.insort(self.nums, num)

    def findMedian(self):
        a,b = divmod(len(self.nums),2)
        return self.nums[a] if b else (self.nums[a] + self.nums[a-1])/2
```
### 解析3：
最大堆保存较小的一半数，堆顶元素是最大的一个；
最小堆保存较大的一半数，堆顶元素是最小的一个；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|220 ms|89.46%|
|空间|$O(n)$|24.8 MB|5.26%|

```python
class MedianFinder:
    
    def __init__(self):
        self.low, self.high = [], []

    def addNum(self, num: int) -> None:
        # 如果两个堆，大小相等，将新元素保存在最大堆中，即较小的一半数
        # 首先最小堆过一遍，返回最小堆和新元素的较小值
        if len(self.low) == len(self.high):
            heapq.heappush(self.low, -heapq.heappushpop(self.high, num))
        else:
        # 如果两个堆，大小不等，有新元素，为使其平衡，将其放在最小堆中，
        # 同时需要过一遍最大堆，返回最小堆和新元素的较大值
            heapq.heappush(self.high, -heapq.heappushpop(self.low, -num))
        
    def findMedian(self) -> float:
        if len(self.low) == len(self.high):
            return (self.high[0] - self.low[0]) / 2
        else:
            return -self.low[0]
```

### 数组中的中位数：
因为求数组中的中位数常考，和本题相似，所以记录下。题目和本题类似，但是非数据流，而是一个固定的数组，求其中位数。

#### 方法1：
排序后返回中间的那个数：

```python
def findmid(nums):
    nums = sorted(nums)
    n = len(nums)
    if n %2 == 1:
        return nums[n//2]
    else:
        return (nums[n//2] + nums[n//2-1])/2
```
                                                                                                                                            
自己实现快排来实现。
```python
def quicksort(nums):
    if len(nums) < 2:
        return nums
    pivot = nums[0]
    left = [x for x in nums[1:] if x <= pivot]
    right = [x for x in nums[1:] if x > pivot]
    return quicksort(left) + [pivot] + quicksort(right)

def findmid(nums):
    nums = quicksort(nums)
    n = len(nums)
    if n %2 == 1:
        return nums[n//2]
    else:
        return (nums[n//2] + nums[n//2-1])/2
```

#### 方法2：
使用双堆来实现，和解析3是一样的，将较小和较大的一半数分别保存在两个堆中。

```python
import heapq
def findmid(nums):
    n = len(nums)
    low,high = [],[]
    for num in nums:
        if len(low) == len(high):
            heapq.heappush(low, -heapq.heappushpop(high, num))
        else:
            heapq.heappush(high, -heapq.heappushpop(low, -num))
    if len(low) == len(high):return (high[0]- low[0])/2
    else:return -low[0]
```

#### 方法3：
快排思想来实现。两种不同的写法。

```python
class Solution:
    def median(self, nums):
        # write your code here
        if not nums or len(nums) == 0:
            return
        
        return self.sortQuick(nums, 0, len(nums) - 1, (len(nums) + 1) // 2)
        
    def sortQuick(self, nums, start, end, k):
        if start == end:
            return nums[start]
        
            
        left, right =  start, end
        pivot = nums[left + (right - left) // 2]
        while left <= right:
            while left <= right and nums[left] < pivot:
                left += 1
            while left <= right and nums[right] > pivot:
                right -= 1
            if left <= right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        
        if start + k - 1 <= right:
            return self.sortQuick(nums, start, right, k)
        if start + k - 1 >= left:
            return self.sortQuick(nums, left, end, k - (left - start))
            
        return nums[right + 1]
```


```python
def part(arr, start, end):
    left = start
    right = end
    key = arr[end]

    while left < right:
        while left < right and arr[left] <= key:left += 1
        while left < right and arr[right] >= key:right -= 1

        if left < right:
            arr[left],arr[right] = arr[right],arr[left]
    arr[right],arr[end] = arr[end],arr[right]
    return left


def findmid(arr,size):
    start = 0
    end = size - 1
    mid = (size-1)//2
    div = part(arr, start, end)

    while div != mid:
        # 在左半边区间找
        if mid < div:div = part(arr, start, div-1)
        # 右半边区间找
        else:div = part(arr, div + 1, end)
    return arr[mid]
```
### 题目：
给定一个无序的整数数组，找到其中最长上升子序列的长度。

>示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

### 解析1：
动态规划，主要依然是建立状态方程。dp[i]是之前严格小于 nums[i] 的“状态”最大值加 1。
* 状态含义：dp[i] 以i借我的最大上升子序列长度；
* 状态方程：dp[i] = max{1 + dp[j] for j < i if nums[j] < nums[i]}

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|1356 ms|10.87%|
|空间|$O(n)$|11.9MB|30.28%|

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        n = len(nums)
        if n < 2:return n
        
        dp = [1]*n
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)       
```

### 解析2：
采用贪心+二分法。最终的最小值序列，应该是由相对较小的值组成的。建立一个list存储最小的上升子序列。

步骤：
1. 建立一个list临时数组res，保存最小上升子序列的辅助序列；
2. 遍历数组：
   1. 如果res[-1] < val，res.append(val)
   2. 然后找到res[0] < val <= res[-1]，找到val在res中应该的位置（第一个>=val的元素），替换他；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn$|32 ms|95.14%|
|空间|$O(n)$|11.9MB|30.28%|

```python
from bisect import bisect_left
class Solution(object):
    def lengthOfLIS(self, nums):
        n = len(nums)
        if n < 2:
            return n
        res = [nums[0]]
        
        for i in range(1, n):
            if nums[i] > res[-1]:
                res.append(nums[i])
                continue
            # 通过二分模块实现查找
            index = bisect_left(res,nums[i])
            res[index] = nums[i]
        return len(res)
```

### 解析3：
思路和上述类似，手动实现查找。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn$|44 ms|80.15%|
|空间|$O(n)$|12MB|12.22%|

```python
from bisect import bisect_left
class Solution(object):
    def lengthOfLIS(self, nums):
        n = len(nums)
        if n < 2:
            return n

        res = [nums[0]]
        
        for i in range(1, n):
            if nums[i] > res[-1]:
                res.append(nums[i])
                continue
            
            left = 0
            right = len(res)-1
            
            while left < right:
                mid = (left+right)>>1
                if res[mid] < nums[i]:
                    # 中位数肯定不是要找的数，把它写在分支的前面
                    left = mid + 1
                else:
                    right = mid
            res[left] = nums[i]
        return len(res)
```


### 相似题目：
300.最长上升子序列
53.最大子序和
 
### 题目：
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

>输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

### 解析1：
同样使用动态规划，和122类似，但是时间上有些不同，前一天买了今天不能再买。

**状态转移方程：**
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp0 = max(dp0, dp1+prices[i])  
第i天未持有股票获得的最多利润 = max(第i-1天未持有股票获得的最多利润， 第i-1天持有股票获得的最多利润 卖掉 prices[i])

dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
第i天持有股票获得的最多利润 = max(第i-1天持有股票获得的最多利润， 第i-2天未持有股票获得的最多利润 买入 prices[i])
```

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|23.42%|
|空间|$O(1)$|11.9MB|14.42%|

```python
class Solution(object):
    def maxProfit(self, prices):
        n = len(prices)
        dp0, dp1 = 0,float('-inf')
        dp_pre_0 = 0
        for i in range(n):
            temp = dp0
            dp0 = max(dp0, dp1+prices[i])
            dp1 = max(dp1, dp_pre_0-prices[i])
            dp_pre_0 = temp
        return dp0
```

### 解析2：
和上述思路相同，但是换一种方式，使用数组来保存每一个状态。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|38.14%|
|空间|$O(1)$|11.8MB|19.23%|


```python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        
        n = len(prices)
        dp0,dp1 = [0]*n, [0]*n
        dp0[0], dp1[0] = 0, -prices[0]

        for i in range(1, n):
            dp0[i] = max(dp0[i-1], dp1[i-1] + prices[i])
            if i < 2:
                dp1[i] = max(dp1[i-1], -prices[i])
            else:
                dp1[i] = max(dp1[i-1], dp0[i-2]-prices[i])
        return dp0[n-1]
                
        
```


### 购买股票类问题总结：
* [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)  
* [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 
* [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)  
* [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) 
* [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)  
* [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)  
* [一个方法团灭 6 道股票问题](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/)  

### 题目：
有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
```
示例:

输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

### 解析1：
动态规划，但是状态转移方程比较难得到，所以重点是状态转移方程的推导。

状态含义：dp[i][j] 戳破[i+1,...j-1]号气球的最大收益；
状态转移方程：dp[i][j] = max(nums[i] * nums[k] * nums[j] + dp[i][k]+dp[k][j]) for k in range(i+1,j)
，假设k为这一段最后一个戳破的。

讲解这个状态方程是如何得到的：   

假设数组是[1，2，3，4，5，6，7，8]，假设i=0,j=7,dp[0][7]表示[2,3,4,5,6,7]这段的最大值，假设k为3，则将这两段划分成[2,3]和[5,6,7]，那么在k之前，剩下的便是nums[i],nums[k]和nums[j]，所以最后是nums[i]*nums[k] *nums[k]，k之前的也需要考虑进去，即dp[i][k]和dp[k][j]，所以产生了上述的状态转移方程。

```python
class Solution(object):
    def maxCoins(self, nums):
        nums = [1] + nums + [1] # build the complete array 
        n = len(nums)
        dp = [[0] * n for _ in range(n)]

        for gap in range(2, n):
            for i in range(n-gap):
                j = i + gap
                for k in range(i+1, j):
                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])
        return dp[0][n-1]
```
### 题目：
给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
```
示例:

输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

### 解析1：
暴力法，遍历当前数后面的数，求小于当前树的个数，明显超时。


```python
class Solution(object):
    def countSmaller(self, nums):
        res = []
        n = len(nums)
        for i in range(n):
            temp = 0
            for j in range(i+1, n):
                if nums[j] < nums[i]:temp += 1
            res.append(temp)
        return res
```
### 题目：

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
```
示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1
```

### 解析1：
动态规划。

状态含义：dp[i]凑成金额i所需的最少的硬币个数；
转移方程：dp[i] = min(dp[i], dp[i-coin]+1) for coin in coins if i >= coin

即遍历硬币组合；总金额amount的所需硬币个数即，去掉某个硬币值后所需个数dp[i-coin]+1。遍历所有情况，取最小值即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|2256 ms|34.46%|
|空间|$O(n)$|13.7 MB|14.79%|

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount+1]*(amount+1)
        n = len(coins)
        dp[0] = 0
        for i in range(1, amount+1):
            for j in range(n):
                if i >= coins[j]:
                    dp[i] = min(dp[i], dp[i-coins[j]]+1)
        return -1 if dp[amount] > amount else dp[amount]
```
### 题目：
给定一个整数，写一个函数来判断它是否是 3 的幂次方。
```
示例 1:

输入: 27
输出: true
```

### 解析1：
直接循环判断，没啥好说的。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|140 ms|36.93%|
|空间|$O(n)$|14 MB|5.64%|


```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n==0:return False
        while n!=1:
            if n%3 == 0:n = n//3
            else:return False
        return True
```
### 题目：
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
```
示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

### 解析1：
设置奇偶指针，偶数指针单独列出得到一个链表，将链表中的奇偶元素单独提取出来。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|76 ms|99.94%|
|空间|$O(1)$|28.7 MB|5.04%|


```python
class Solution(object):
    def oddEvenList(self, head):
        if not head:return None
        res = odd = head
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            
            even.next = odd.next
            even = even.next
        odd.next = evenHead
        return res
```
### 题目：
给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

如果存在这样的 i, j, k,  且满足 0 ≤ i < j < k ≤ n-1，
使得 arr[i] < arr[j] < arr[k] ，返回 true ; 否则返回 false 。
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。
```
示例 1:
输入: [1,2,3,4,5]
输出: true
```

### 解析1：
利用300的结论，先求最长上升子序列，然后判断是否大于等3，具体如何求最长上升子序列，见题300。需要简单的修改。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|60 ms|39.79%|
|空间|$O(n)$|12.3 MB|20.09%|

```python
from bisect import bisect_left
class Solution(object):
    def increasingTriplet(self, nums):
        n = len(nums)
        if n < 2:
            # 这种情况返回False，注意下
            return False
        res = [nums[0]]
        for i in range(1, n):
            if nums[i] > res[-1]:
                res.append(nums[i])
                continue
            left = bisect_left(res,nums[i])
            res[left] = nums[i]

        return len(res) >= 3
```


### 解析2：
寻找一个a < b < c的三元组即可，如果找到小值，较大值，较较大值即可。复杂度是$O(n)$。但是时间很长，猜测是数据量太少导致的。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|60 ms|14.88%|
|空间|$O(1)$|12.2 MB|30.09%|

```python
class Solution(object):
    def increasingTriplet(self, nums):
        min1, min2 = float('inf'), float('inf')
        for i in nums:
            if i <= min1:
                min1 = i
            elif i <= min2:
                min2 = i
            else:
                return True
        return False
```

### 解析3：
qiyinjiqiao比较多。有毒，同样的代码，中文版和英文版时间不一样。

```python
class Solution(object):
    def increasingTriplet(self, nums):
        if len(nums) < 3:
            return False
        i,j,k = 0,1,2
        while k < len(nums):
            if nums[i] < nums[j] and nums[j]<nums[k]:
                return True
            while nums[j] <= nums[i]:
                i = j
                j,k = i+1,i+2
                if k > len(nums)-1:
                    return False
            while nums[k] <= nums[j]:
                k += 1
                if k > len(nums)-1:
                    j,k = j+1,j+2
                    break
        return False  
```
### 题目：
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

>示例 1:
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

### 解析1：
动态规划还是不太懂。DFS函数返回一个数组，第一位代表不包括当前结点值的最大值，第二位代表包括当前结点的最大值。对树进行前序遍历，遍历到node结点，如果不选node结点，则其对应的最大值为max(l)+max(r)。如果选这个结点，则对应的最大值为cur.val+l[0]+r[0]。

最后返回根节点，DFS返回数组的最大值即可，即包括根节点与不包括根结点的最大值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|44 ms|80.30%|
|空间|$O(1)$|15.9 MB|19.35%|


```python
class Solution:
    def DFS(self , cur):
        if not cur :
            return [0,0]
        
        l = self.DFS(cur.left)
        r = self.DFS(cur.right)
         
        return [max(l)+max(r),cur.val+l[0]+r[0]]
    def rob(self, root):
        return max(self.DFS(root))
```
### 题目：
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```
示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
```

### 解析1：
和191完全类似，遍历求解每个数二进制表示中1的个数。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|96 ms|41.38%|
|空间|$O(n)$|15.7 MB|38.16%|

```python
class Solution(object):
    def countBits(self, num):
        res = []
        for i in range(num+1):
            res.append(bin(i).count('1'))
        return res
```
### 题目：
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
```
示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

### 解析1：
贪心法：将绳子划分成更多的段，并且没有1，乘积会最大
* 尽可能找到更多的3；
* 没有3了找到尽可能多的2；
* 然后得到1

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(1)$|40 ms|48.91%|
|空间|$O(1)$|13.4 MB|100%|

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n <= 3:return n-1
        a,b = n%3,n//3
        if a == 0:return 3**b
        elif a == 1:return 3**(b-1)*4
        else:return 3**b*2
```
### 题目：
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

```
示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

### 解析1：
主要是原地翻转。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|340 ms|73.50%|
|空间|$O(1)$|18.5 MB|95.55%|

```python
class Solution(object):
    def reverseString(self, s):
        s[0::]=s[::-1]
```
### 题目：
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

>示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

### 解析1：
统计每个数出现的次数，然后对其进行排序。

时间：O(nlogn) 
空间：O(n) 
n不相同元素的个数

```python
class Solution(object):
    def topKFrequent(self, nums, k):
        num_count = {}
        res = []
        for i in range(len(nums)):
            num_count[nums[i]] = num_count.get(nums[i], 0) + 1

        num_count = sorted(num_count.items(),key=lambda x:x[1],reverse=True)
        return list(dict(num_count[:k]).keys())
```

此处需要对字典进行排序，记录下字典排序相关的内容。
```python
nums_count = {}

# 对key进行排序：
num_count = sorted(num_count)

# 倒序对字典的value值进行排序，返回一个tuple构成的list
num_count = sorted(num_count.items(), key=lambda x:x[1], reverse=True)
```

### 解析2：
和215题相似，获得每个数的统计次数后，求前k个，即前k个最大的元素，所以考虑使用最小堆实现。用python实现很骚。collections统计每个数出现的次数，headpq求前k大元素。key的书写不是很明白。

时间：O(nlogk)
空间：O(n)

```python
import collections,heapq
class Solution(object):
    def topKFrequent(self, nums, k):
        count = collections.Counter(nums)
        return heapq.nlargest(k, count.keys(), key=count.get) 
```

同样的思路，手动实现最小堆要快。
```python
import collections,heapq
class Solution(object):
    def topKFrequent(self, nums, k):
        h =[]
        count = {}
        for num in nums:
            count[num] = count.get(num,0) + 1
        for key,val in count.items():
            heapq.heappush(h,(val, key))     
            # 不断往最小堆中压入数，如果大于k就pop
            if len(h) > k:
                heapq.heappop(h)
        return [el[1] for el in h]
```

### 解析3：
通过桶排序来实现，这种方法比较妙，推荐。统计每个数出现的次数后，创建一个数组，将频率作为数组下标，出现次数作为数组值。
```python
import collections,heapq
from collections import defaultdict,Counter
class Solution(object):
    def topKFrequent(self, nums, k):
        frq = defaultdict(list)
        for key, cnt in Counter(nums).items():
            frq[cnt].append(key)

        res = []
        for times in reversed(range(len(nums) + 1)):
            res.extend(frq[times])
            if len(res) >= k: return res[:k]

        return res[:k]
```
### 题目：
给定两个数组，编写一个函数来计算它们的交集。
```
示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
```
### 解析1：
暴力法，依次判断是否出现过，需要注意重复词。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n×m)$|56 ms|53.04%|
|空间|$O(n)$|11.8 MB|31.44%|

```python
class Solution(object):
    def intersect(self, nums1, nums2):
        res = []
        for i in range(len(nums1)):
            if nums1[i] in nums2:
                res.append(nums1[i])
                nums2.remove(nums1[i])
        return res
```

### 解析2：
使用哈希表来实现。Counter统计每个数组的次数，然后取与，取与会得到共有的key同时选择value较小的值。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n,m)$|56 ms|94.04%|
|空间|$O(n)$|11.8 MB|31.44%|

```python
from collections import Counter
class Solution(object):
    def intersect(self, nums1, nums2):
        return [*(collections.Counter(nums1) & collections.Counter(nums2)).elements()]
```

## 解析3：
排序，排序后进行比较，如果相等，则拼接，根据大小关系调整ij的索引。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlog(n),mlog(m))$|56 ms|94.04%|
|空间|$O(n)$|13.9 MB|5.06%|

```python
class Solution(object):
    def intersect(self, nums1, nums2):
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        i = j =0
        res = []
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                res.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
        return res
```
### 题目：
不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
```
示例 1:

输入: a = 1, b = 2
输出: 3
示例 2:

输入: a = -2, b = 3
输出: 1
```

### 解析1：
emmm有点迷，直接相加吧。

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        return a+b


```
### 解析2：
二进制，模拟进位操作，异或和与操作。因为python中整数不是32位，所以需要模拟32位操作，进行数值上的调整。


```python
class Solution(object):
    def getSum(self, a, b):
        # 2^32
        MASK = 0x100000000
        # 整型最大值
        MAX_INT = 0x7FFFFFFF
        MIN_INT = MAX_INT + 1
        while b != 0:
            # 计算进位
            carry = (a & b) << 1 
            # 取余范围限制在 [0, 2^32-1] 范围内
            a = (a ^ b) % MASK
            b = carry % MASK
        return a if a <= MAX_INT else ~((a % MIN_INT) ^ MAX_INT)  
```
### 题目：
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。
```
示例:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

### 解析1：
二维数组展开，然后排序，返回第k个，暴力法，但是速度好像很快啊。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mnlog(mn))$|212 ms|83.49%|
|空间|$O(mn)$|19.7 MB|5.22%|

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        nums = [x for x in line for line in matrix]
        return sorted(nums)[k-1]
```

### 解析2：
二维数组展开，展开后用堆寻找第k小的元素。明显应该更快，但是时间变成了，神奇的leetcode测评时间。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mnlog(k))$|360 ms|40.12%|
|空间|$O(mn)$|19.7 MB|5.22%|

```python
import heapq
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        nums = [x for line in matrix for x in line]
        return heapq.nsmallest(k, nums)[-1]
```

### 解析3：

### 题目：
打乱一个没有重复元素的数组。
```
示例:

// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();
```

### 解析1：
建立一个拷贝数组，random来产生随机数。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|364 ms|94.96%|
|空间|$O(n)$|18.8 MB|97.74%|

```python
import random
class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.ori = nums.copy()

    def reset(self) -> List[int]:
        return self.ori
        
    def shuffle(self) -> List[int]:
        random.shuffle(self.nums)
        return self.nums
```

### 解析2：
手动实现shuffle算法，具体可看帖子。模拟的均是随机从原数组抽取的一个过程。

* 暴力法：
```python
class Solution:
    def __init__(self, nums):
        self.array = nums
        self.original = list(nums)

    def reset(self):
        self.array = self.original
        self.original = list(self.original)
        return self.array

    def shuffle(self):
        aux = list(self.array)

        for idx in range(len(self.array)):
            remove_idx = random.randrange(len(aux))
            self.array[idx] = aux.pop(remove_idx)

        return self.array
```

*  Fisher-Yates 洗牌算法:
```python
class Solution:
    def __init__(self, nums):
        self.array = nums
        self.original = list(nums)

    def reset(self):
        self.array = self.original
        self.original = list(self.original)
        return self.array

    def shuffle(self):
        for i in range(len(self.array)):
            swap_idx = random.randrange(i, len(self.array))
            self.array[i], self.array[swap_idx] = self.array[swap_idx], self.array[i]
        return self.array
```






https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode/

### random的用法：
此处记录下random的几个用法：

```python
import random

print( random.randint(1,10) )        # 产生 1 到 10 的一个整数型随机数  
print( random.random() )             # 产生 0 到 1 之间的随机浮点数
print( random.uniform(1.1,5.4) )     # 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数
print( random.choice('tomorrow') )   # 从序列中随机选取一个元素
print( random.randrange(1,100,2) )   # 生成从1到100的间隔为2的随机整数

a=[1,3,5,6,7]                # 将序列a中的元素顺序打乱
random.shuffle(a)
print(a)

```
### 题目：
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
```
案例:

s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.
```

### 解析1：
哈希表统计每个词的出现次数，然后遍历即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(logn)$|172 ms|51.95%|
|空间|$O(n)$|14 MB|5.34%|

```python
from collections import Counter
class Solution:
    def firstUniqChar(self, s: str) -> int:
        cnt = Counter(s)
        for i in range(len(s)):
            if cnt[s[i]] == 1:
                return i
        return -1
```
### 题目：
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
```
示例 1:
s = "abc", t = "ahbgdc"

返回 true.
```

### 解析1：
遍历字符串，判断目标字符串的第一个字符是否匹配，如果相互匹配，则去掉这个字符，一旦出现目标字符为空，同样返回True。


|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|120 ms|57.87%|
|空间|$O(n)$|18.9 MB|21.93%|


```python
class Solution(object):
    def isSubsequence(self, s, t):
        s = list(s)
        for char in t:
            if not s:
                return True
            if char == s[0]:
                s.pop(0)

        return not s
```
### 题目
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
```
示例:

s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
```

### 解析1：
主要是栈的利用，将括号外的字符串不断保存，遇到新的然后组合起来。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|40 ms|96.28%|
|空间|$O(n)$|13.8 MB|5.26%|

步骤：
1. 建立一个栈保存依次出现的字符和出现的次数；
2. 遍历字符串：
   1. 如果字符是数字，保存到num:对应括号内要重复的次数；
   2. 如果字符是字母，保存到this_str：是括号外的字符串；
   3. 遇到'['，将this_str和num入栈，this_str对应这一个括号外的字符串,num对应括号内的字符串的重复次数
   4. 同时更新this_str为空，num为0，因为this_str始终保存最新括号内的字符串，num保存括号内字符串的次数；
   5. 遇到']',出栈last_str和this_num，last_str为括号外的字符串，this_num为括号和内字符串出现的次数；
   6. 最后将括号内的字符串和括号外的字符串相加：this_str*this_num + last_str


```python
class Solution:
    def decodeString(self, s: str) -> str:       
        stack, this_str,num = [], '', 0
        for i in s:
            # 会出现‘123’这种字符所以需要num*10 + int(I)
            if i.isdigit():num = num * 10 + int(i) 
            elif i.isalpha():this_str += i
            elif i == '[':
                stack.append((this_str,num))
                this_str, num = '', 0
            else: # i == ']'
                last_str, this_num = stack.pop()
                this_str = last_str + this_num * this_str
        return this_str
```
### 题目：
找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。
```
示例 1:

输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2:

输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

### 解析1：
分治递归，需要弄懂思想，将原字符串进行划分，直到不能划分为止。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|87.72%|
|空间|$O(n)$|12.1 MB|26.14%

步骤：
1. 如果字符串总长度小于k，返回0；
2. 出现次数最少的字符；
3. 如果出现次数最少的字符，次数大于k，返回当前字符串的长度；
4. 如果出现次数最少的字符，次数小于k，以这个字符为分隔符进行分割；


```python
class Solution(object):
    def longestSubstring(self, s, k):
        if len(s) < k:return 0
        c = min(set(s), key=s.count)
        
        if s.count(c) >= k:
            return len(s)
        else:
            return max(self.longestSubstring(t,k) for t in s.split(c))
```
### 题目：
给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。

```
示例 :
给定 a / b = 2.0, b / c = 3.0
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]

输入为: vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector<double>类型。

基于上述例子，输入如下：

equations(方程式) = [ ["a", "b"], ["b", "c"] ],
values(方程式结果) = [2.0, 3.0],
queries(问题方程式) = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. 
输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。
```

### 解析1：
```python
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        # 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数
        graph = {}
        for (x, y), v in zip(equations, values):
            if x in graph:
                graph[x][y] = v
            else:
                graph[x] = {y: v}
            if y in graph:
                graph[y][x] = 1/v
            else:
                graph[y] = {x: 1/v}
        
        # dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果
        def dfs(s, t) -> int:
            if s not in graph:
                return -1
            if t == s:
                return 1
            for node in graph[s].keys():
                if node == t:
                    return graph[s][node]
                elif node not in visited:
                    visited.add(node)  # 添加到已访问避免重复遍历
                    v = dfs(node, t)
                    if v != -1:
                        return graph[s][node]*v
            return -1

        # 逐个计算query的值
        res = []
        for qs, qt in queries:
            visited = set()
            res.append(dfs(qs, qt))
        return res
```
### 题目：
二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。

每个 LED 代表一个 0 或 1，最低位在右侧。
给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。
```
案例:

输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
```

### 解析1：
很好玩的一个题，直接的想法是用回溯来做，但是如果知道所有的情况，而且复杂度又不是很高的话，可以考虑遍历所有的情况，然后判断是否满足条件。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(1)$|52 ms|81.39%|
|空间|$O(1)$|12.6 MB|23.34%|
因为计算时间是固定的，所以时间复杂度是$O(1)$。

* **算法流程：**
  * 遍历所有时刻，小时0-11，分钟0-59；
  * 然后求一共有多少个1，是否满足题目要求，满足的话就返回到res里面；
  * 分钟小于的10的话需要注意；


```python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        res = []
        def count(num):
            return bin(num).count('1')

        def count(num):
            # 这种求法更慢
            res = 0
            while num:
                res += num&1
                num >>= 1
            return res
        for i in range(12):
            for j in range(60):
                if count(i)+count(j) == num:
                    if j<10:
                        res.append(str(i)+':0'+str(j))
                    else:
                        res.append(str(i)+':'+str(j))
        return res
```
### 题目：
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。
```
示例

输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

### 解析1：
对身高队列进行排序。身高按降序排序，人数按升序排序。最高的人的顺序，不依赖其他人的位置，所以他的位置为空数组插入p[1]的位置。后面的人，所处的位置，需依赖比他高的所有的人。所以从高到底开始插入。频次频次从大到小排序。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|96 ms|91.38%|
|空间|$O(n)$|12 MB|22.22%|

时间复杂度依赖于排序的复杂度。

```python
class Solution(object):
    def reconstructQueue(self, people):
    # 对身高升序排序，对人数降序排序        
        people = sorted(people, key=lambda x:[-x[0],x[1]])
        res = []
        for p in people:
            res.insert(p[1],p)
        return res
```
### 题目：
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

注意:
数组长度 n 满足以下条件:

1 ≤ n ≤ 1000
1 ≤ m ≤ min(50, n)
```
示例:

输入:
nums = [7,2,5,10,8]
m = 2

输出:
18
```

### 解析1：
思路通，但是还是有些麻烦。


```python
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def countGroups(mid):
            temp = 0
            count = 1
            for num in nums:
                temp += num
                if temp > mid:
                    count += 1
                    temp = num # 准备下一组
            return count
        
        left, right = max(nums), sum(nums)
        
        while left < right:
            mid = left + (right - left) // 2
            num_group = countGroups(mid)
            
            if num_group > m: # 划分多了，mid太小了
                left = mid + 1
            else:
                right = mid
        print(left, mid, right)
        return left # left恰好是满足条件的最少分割，自然就最大
```
### 题目：
写一个程序，输出从 1 到 n 数字的字符串表示。

1. 如果 n 是3的倍数，输出“Fizz”；

2. 如果 n 是5的倍数，输出“Buzz”；

3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。


### 解析1：
无他，直接遍历数字，然后拼接。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|76 ms|37.27%|
|空间|$O(n)$|14.7 MB|5.25%|

```python
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1,n+1):
            if i % 3==0 and i%5 == 0:
                res.append('FizzBuzz')
            elif i % 3 == 0:
                res.append('Fizz')
            elif i % 5 == 0:
                res.append('Buzz')
            else:
                res.append(str(i))
        return res
```
### 题目：
给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

>示例 1:
输入: [3, 2, 1]
输出: 1
解释: 第三大的数是 1.

### 解析1：
排序然后返回，注意边界条件，nums数量小于3，重复的元素只能算一次所以需要取集合。


时间：O(nlogn)
空间：O(1)

```python
class Solution(object):
    def thirdMax(self, nums):
        nums = sorted(list(set(nums)))
        if len(nums) < 3:
            return max(nums)
        return nums[-3]
```

### 解析2：
依然是使用最小堆来实现。理论上这种方法应该更快，时间惊人的慢。

时间：O(nlogk)
空间：O(1)

```python
class Solution(object):
    def thirdMax(self, nums):
        nums = list(set(nums))
        if len(nums) < 3:
            return max(nums)
        return heapq.nlargest(3, nums)[-1]
```

三个数，数量较小，可以直接比较。

### 题目：
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
```
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

### 解析1：
动态规划，其实就是求，是否存在子序列的和为sum(nums)//2。DP求解。
状态含义：dp[i][j] nums的前i个元素是否存在子序列，使得和为j；
状态方程：dp[i][j] = dp[i-1][j] 如果子序列和包括nums[i] dp[i-1][j-nums[i]]如果不包括nums[i]

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(ns)$|1508 ms|33.50%|
|空间|$O(ns)$|17.9 MB|20.55%|

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        s = sum(nums)
        if s%2 == 1:
            return False
        target = s//2
        dp = [[False for _ in range(target+1)] for _ in range(n)]
        
        for i in range(target+1):
            dp[0][i] = False if nums[0] != i else True
        
        for i in range(1,n):
            for j in range(target+1):
                if nums[i] <= j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
```

### 解析2：
对DP进行优化。
空间优化，因为dp[i][j]只是和上一行的元素相关，可以简化成用list来表述，而不是二维数组。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(ns)$|976 ms|60.39%|
|空间|$O(ns)$|13.7 MB|20.39%|

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        size = len(nums)
        
        s = sum(nums)
        if s & 1 == 1:
            return False

        # 从第 2 行以后，当前行的结果参考了上一行的结果，因此使用一维数组定义状态就可以了
        target = s // 2
        dp = [False for _ in range(target + 1)]

        # 看看第 1 个数是不是能够刚好填满容量为 target
        for j in range(target + 1):
            if nums[0] == j:
                dp[j] = True
                # 如果等于，后面就不用做判断了，因为 j 会越来越大，肯定不等于 nums[0]
                break

        # 注意：因为后面的参考了前面的，我们从后向前计算
        for i in range(1, size):
            for j in range(target, -1, -1):
                if j >= nums[i]:
                    dp[j] = dp[j] or dp[j - nums[i]]
                else:
                    # 后面的容量越来越小，因此没有必要再判断了，退出当前循环
                    break

        return dp[-1]
```
### 题目：
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

```
示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

### 解析1：
迭代，将到达每一个结点的路径段，均保存在一个list中，然后拼成一个元组保存在stack中。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|224 ms|87.55%|
|空间|$O(n)$|12.4 MB|50.83%|

步骤：
1. 建立一个栈，保存元组，元组内为结点和到达该结点的所有路径段；
2. 遍历栈，此处是一样的，但是加一个判断，判断在包含当前结点的所有路径段中total的个数；
3. 添加新的结点，主要是路径段的添加，已知的每一个路径段，加上当前结点值，以及当前结点值：[x+node.right.val for x in totals]+[node.right.val];
4. 左右结点同样类似；

```python
class Solution(object):
    def pathSum(self, root, total):
        if not root:
            return 0
        
        stack = [(root, [root.val])]
        num = 0
        
        while stack:
            node, totals = stack.pop()
            
            num += totals.count(total)
            if node.right:
                stack.append((node.right, [x+node.right.val for x in totals]+[node.right.val]))
                
            if node.left:
                stack.append((node.left, [x+node.left.val for x in totals]+[node.left.val]))

        return num
```
### 题目：
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。
示例 1:

```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```

### 解析1：
暴力法，滑窗依次判断子字符串是否是异位词。超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nm)$|超时||
|空间|$O(n+m)$|| |

```python
class Solution(object):
    def findAnagrams(self, s, p):
        n,m = len(s),len(p)
        res = []
        dict1 = {}
        for char in p:
            dict1[char] = dict1.get(char,0)+1

        for i in range(n-m+1):
            dict2 = {}
            for char in s[i:i+m]:
                dict2[char] = dict2.get(char,0)+1
            if dict2 == dict1:
                res.append(i)
        return res
```

### 解析2：

滑窗法，具体思路和76相类似，依然是移动左右边界，是否是异位词，即判断match满足要求，同时长度和目标字符串相同。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n+m)$|108 ms|72.78%|
|空间|$O(n+m)$|12.6 MB|42.86%|

```python
class Solution(object):
    def findAnagrams(self, s, p):
        left, right,match = 0,0,0
        needs = {}
        for char in p:
            needs[char] = needs.get(char,0) + 1
        
        req = len(needs)
        ans = []
        windows = {}
        while right < len(s):
            char = s[right]
            windows[char] = windows.get(char, 0) + 1
            
            if char in needs and windows[char] == needs[char]:
                match += 1
                
            while left <= right and match == req:
                char = s[left]
                
                if right-left+1 == len(p):
                    ans.append(left)
                    
                windows[char] -= 1
                if char in needs and windows[char] < needs[char]:
                    match -= 1
                    
                left += 1
            right += 1
        return ans
```
### 题目：
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
```
示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

### 解析1：
遍历数组，判断是否出现。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|80 ms|67.44%|
|空间|$O(n)$|13.9 MB|8.64%|

```python
class Solution(object):
    def findDisappearedNumbers(self, nums):
        n,res = len(nums),[]
        nums = set(nums)
        for i in range(1,n+1):
            if i not in nums:
                res.append(i)
        return res
```

### 解析2：
骚操作，数组中存在的数，将其作为索引，索引对应原数组的数求反。最后提取大于0的数组元素的索引。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|760 ms|10.75%|
|空间|$O(1)$|19 MB|50.62%|

步骤:
1. 遍历数组，将abs(num)-1作为索引，对对应的数值求反；
2. 数组中存在的数字，在nums中对应的索引便变成负；
3. 求数组中依然大于0的元素，其索引+1便是所求结果；



```python
class Solution(object):
    def findDisappearedNumbers(self, nums):
        for num in nums:
            index = abs(num)-1
            nums[index] = -abs(nums[index])
            
        return [i+1 for i in range(n) if nums[i] > 0]
```
### 题目：
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

```
示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```

### 解析1：
两个数做异或，然后统计二进制中1的个数。不同为1，相同为0。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|20 ms|82.50%|
|空间|$O(n)$|11.8 MB|18.10%|


```python
class Solution(object):
    def hammingDistance(self, x, y):
        return bin(x^y).count('1')
```

### 解析2：
通过位运算来求1的个数。依次判断最右边是否是1，然后移位。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|28 ms|36.21%|
|空间|$O(n)$|11.7 MB|25.46%|

```python
class Solution:
    def hammingDistance(self,x, y):
        count = 0
        x = x ^ y
        while True:
            if x & 1 == 1:
                count += 1
            if x == 0:
                return count
            x >>= 1
```

### 解析3：
转换成二进制，然后进行比较，比较不同位数的数目。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(n)$|24 ms|98%|
|空间|$O(1)$|13.4 MB|23.34%|

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        x = bin(x)[2:]
        y = bin(y)[2:]
        maxlen = max(len(x),len(y))
        x = x.zfill(maxlen)
        y = y.zfill(maxlen)
        res = 0

        for i in range(maxlen):
            if x[i] != y[i]:
                res += 1
        return res
```
### 题目：
两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

计算一个数组中，任意两个数之间汉明距离的总和。

```
示例:

输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
```

### 解析1：
利用461.汉明距离，计算数组内每两对数的汉明距离，然后求和。但是超时。

n:数据量；m二进制位数；  
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|||
|空间|$O(nm)$|||

```python
class Solution(object):
    def totalHammingDistance(self, nums):
        def HD(num1, num2):
            return bin(num1^num2).count('1')
        res = 0
        n = len(nums)
        for i in range(n-1):
            for j in range(i+1, n):
                res += HD(nums[i],nums[j])
        return res
```

### 解析2：
* **算法流程：**
  * 遍历32位，依次比较每一位；
  * 比较每一位，数组中所有数1的个数cnt1和0的个数cnt0，这一位不相同的种数便是cnt1*cnt0;
  * 将每一位不同的组合数相加

将横向比较，变为纵向比较。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(36n)$|952 ms|11.25%|
|空间|$O(nm)$|12.4 MB|40.00%|

```python
class Solution(object):
    def totalHammingDistance(self, nums):
        res = 0
        n = len(nums)
        for i in range(32):
            cnt1 = 0
            for i in range(n):
                if nums[i] & 1 != 0:
                    cnt1 += 1
                nums[i] >>= 1
            res += cnt1*(n-cnt1)
        return res
```

### 题目：
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```
示例 1:

输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```


### 解析1：
回溯法，遍历所有的可能。暴力回溯，直接超时。
状态含义：$f(i,target)$：[0:i]这个区间以target为结尾的方法数
状态方程：$f(i,target) = f(i-1,target-nums[i]) + f(i-1, target+nums[i])$

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(2^n)$|超时| |
|空间|$O(1)$| | |

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        return self.backtrack(nums, 0, S)
    
    def backtrack(self, nums, index, target):
        if index == len(nums):
            if target == 0:
                return 1
            else:
                return 0
        
        return self.backtrack(nums, index+1, target-nums[index]) + \
                self.backtrack(nums, index+1, target+nums[index])
```

### 解析1：
转换成0-1背包问题。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|100 ms|85.31%|
|空间|$O(n)$|13.9 MB|7.35%|

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        if sum(nums) < S or (sum(nums) + S) % 2 == 1: return 0
        P = (sum(nums) + S) // 2
        dp = [1] + [0 for _ in range(P)]
        for num in nums:
            for j in range(P,num-1,-1):dp[j] += dp[j - num]
        return dp[P]
```
### 题目：
给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。

```python
示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
```

### 解析1：
利用739题，由于nums1是nums2的子集。利用739题可以求，nums2中每一个数对应的下一个比他大的数，只是索引变成了数。题目让求nums1中的，即对应到nums相应的索引即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|64ms|66.43%|
|空间|$O(n)$|11.9MB|32.12%|

步骤：
1. 求nums2中每一个数下一个比当前元素大的数，不存在则是-1；
2. 由于不重复且是子集，则将nums1中的元素对应到nums2中；

```python
class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        def nextBig(nums):
            res,stack = [-1]*len(nums),[]
            for i,v in enumerate(nums):
                while stack and nums[stack[-1]] < v:
                    res[stack.pop()] = v
                stack.append(i)
            return res

        res2 = nextBig(nums2)
        res = []
        for i in range(len(nums1)):
        # 次数复杂度较高，其实是O(mn)
            res.append(res2[nums2.index(nums1[i])])
        return res
```

### 解析2：
思路相同，只不过是通过哈希表（字典）来保存每个数所对应的比他大的元素。然后遍历一遍nums找到哈希表里面对应的数即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|40ms|94.76%|
|空间|$O(n)$|11.8MB|39.39%|

```python
class Solution:
    def nextGreaterElement(self, nums1, nums2):
        stack, hash = [], {}
        for n in nums2:
            while stack and stack[-1] < n:
                hash[stack.pop()] = n
            stack.append(n)
        
        return [hash.get(x, -1) for x in nums1]
```
### 题目：
给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```
示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

### 解析1：
思路和496是一样的，只不过加入了一个循环数组。没什么太大不同，将nums重复一遍，如果循环后出现了肯定能在后面找到。最后返回前n个即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|268ms|43.18%|
|空间|$O(n)$|14.1MB|11.88%|

步骤：
1. 将原数组复制一遍
```python
class Solution(object):
    def nextGreaterElements(self, nums):
        nums2 = nums + nums
        n = len(nums)
        res,stack = [-1]*2*n, []
        for i,v in enumerate(nums2):
            while stack and stack[-1][1] < v:
                res[stack[-1][0]] = v
                stack.pop()
            stack.append([i,nums2[i]])
        return res[:n]
```
### 题目：
斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

```
示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
```


### 解析1：
本质是DP，对DP进行了拆解。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|36 ms|63.40%|
|空间|$O(1)$|13.1 MB|49.07%|

```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:return 0
        f1,f2 = 0,1
        for i in range(n-1):
            f2,f1 = f1+f2,f2
        return f2 % 1000000007
```
### 题目：
给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

```
示例 1:

输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。

示例 2:

输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
```

### 解析1：
遍历数组，求子数组的和，然后判断子数组和是否是k的倍数，此处需要注意0的存在，也就是k为0的情况。代码只需判断何时返回True即可。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|908 ms|16.48%|
|空间|$O(1)$|12.3 MB|5.55%|

步骤：
1. 判断k为0的时候，temp_sum是否为0，并且j-i>0（子数组大小至少2）；
2. k不为0的时候，即判断是否正整除k；

```python
class Solution(object):
    def checkSubarraySum(self, nums, k):
        n =len(nums)
        for i in range(n):
            temp = 0
            for j in range(i+1, n):
                temp += nums[j]
                if k == 0 and temp ==0  or  and j-i>0:return True
                if k != 0 and temp % k == 0 and j-i>0:return True
        return False
```
简单优化下代码，没啥区别。

```python
class Solution(object):
    def checkSubarraySum(self, nums, k):
        n = len(nums)
        
        for i in range(n-1):
            temp = nums[i]
            for j in range(i+1, n):
                temp += nums[j]
                if k == 0 and temp == 0 or k != 0 and temp % k ==0:
                    return True
        return False
```


### 题目:
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

```
例如：

输入: 二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

### 解析1：
递归遍历。DFS，先遍历右子树，保存结点值，对根结点值进行累加，然后遍历左子树。相当于中序遍历的倒序，依次将前一个结点值的加在当前结点。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|60 ms|98.42%|
|空间|$O(n)$|16.3 MB|10.94%|

```python
class Solution(object):
    def convertBST(self, root):
        self.val = 0

        def dfs(root):
            if not root:return
            dfs(root.right)
            self.val += root.val
            root.val = self.val
            dfs(root.left)
        
        dfs(root)
        return root     
```

二叉树的搜索查找和插入：https://blog.csdn.net/yht201293018/article/details/81229372
### 题目：
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。
```
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。
```

### 解析1：
其实是求树最大深度的变种，和求树的深度相类似，在求深度的同时，更新直径。递归遍历每一个结点，求当前节点的左右子树的深度，同时更新以当前结点为路径起点的路径直径。注意最后的返回值，即路径的定义。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|95.77%|
|空间|$O(n)$|16.3 MB|5.10%|

步骤：
1. 遍历树的每个结点，求以其为根节点的树深度；
2. 求以当前结点为公共祖先的两个叶节点的路径：左子树深度+右子树深度+1
```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def helper(root):
            if not root:return 0
            L = helper(root.left)
            R = helper(root.right)
            self.ans = max(self.ans, L+R+1)
            return max(L,R) + 1
        helper(root)
        return self.ans-1
```
### 题目：
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
```
示例 1:

输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
```

### 解析1：

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|32 ms|100%|
|空间|$O(logn)$|14.3 MB|5.04%|

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join([x[::-1] for x in s.split()])
```
### 题目：
给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 3叉树 :

我们应返回其最大深度，3。

说明:

树的深度不会超过 1000。
树的节点总不会超过 5000。

### 解析1：
DFS递归遍历。

* **算法流程：**


|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|63%|
|空间|$O(logN)$|15.5 MB|26.14%|


```python
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:return 0
        if not root.children:return 1
        # max的list不能为空
        return max([self.maxDepth(node) for node in root.children]) + 1
```
### 题目：
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

```
示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

### 解析1：
暴力法，遍历每一个子数组，然后求和。直接超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|超时||
|空间|$O(1)$|||

```python
class Solution(object)
    def subarraySum(self, nums, k):
        res,n = 0,len(nums)
        for i in range(n):
            for j in range(i,n):
                if sum(nums[i:j+1]) == k:
                    res += 1
        return res             
```

### 解析2：
暴力法，和解法1差不多，从i向后累积求和，不是去子数组然后求和，降低一层复杂度。但是同样超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(1)$|||


```python
class Solution(object):
    def subarraySum(self, nums, k):
        res,n = 0,len(nums)
        
        for i in range(n):
            temp = 0
            for j in range(i,n):
                temp += nums[j]
                if temp == k:
                    res += 1
        return res
```    

### 解析3：
建立一个字典，保存累积求和存在的次数。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|116 ms|94.44%|
|空间|$O(1)$|13.9 MB|11.67%|

步骤：
1. 建立一个字典，保存累积和出现的次数，建立一个temp_sum保存累积求和；
2. 遍历数组，
   1. 如果temp_sum-k在字典里面，则说明存在子数组的和为k，而且子数组的种数为cnt_dict[temp_sum-k]
   2. 将temp_sum出现的次数保存在字典里面；

```python
class Solution(object):
    def subarraySum(self, nums, k):
        res,n = 0,len(nums)
        cnt_dict = {0:1}
        temp_sum = 0
        for i in range(n):
            temp_sum += nums[i]
            if temp_sum - k in cnt_dict:
                res += cnt_dict[temp_sum-k]
            cnt_dict[temp_sum] = cnt_dict.get(temp_sum, 0) + 1
        return res         
```
### 题目
给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。

```
示例 1:

输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :

输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是<=。
```

### 解析1：
对原数组进行排序，然后求第一个和最后一个不相等的元素之间的距离。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|256 ms|57.44%|
|空间|$O(n)$|12.8 MB|18.42%|

步骤：
1. 对原数组进行排序；
2. 遍历数组，找到原数组和排序后数组第一个不相等元素索引left，和最后一个不相等的元素索引right；
3. 如果left和right不相等返回right-left+1；如果相等返回0；

```python
class Solution(object):
    def findUnsortedSubarray(self, nums):
        nums2 = sorted(nums)
        n = len(nums)
        left,right = 0,0
        for i in range(n):
            if nums2[i] != nums[i]:
                left = i
                break
        for i in reversed(range(n)):
            if nums2[i] != nums[i]:
                right = i
                break
                
        return 0 if right == left else right - left + 1
```
### 解析2：
同样的思路，代码更简洁，但是时间几乎翻倍。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(nlogn)$|480 ms|5.48%|
|空间|$O(n)$|13.4 MB|5.26%|

```python
class Solution(object):
    def findUnsortedSubarray(self, nums):
        diff = [i for i, (a, b) in enumerate(zip(nums, sorted(nums))) if a != b]
        return len(diff) and max(diff) - min(diff) + 1
```

### 解析2：
关键就是找到非上升子序列的最小元素，以及最大元素，然后找到最小最大元素在序列中应该的位置。

步骤：
1. 寻找非上升子序列的最小元素，和最大元素；
2. 寻找最小和最大元素，在数组中应该出现的位置；


```python
class Solution(object):
    def findUnsortedSubarray(self, nums):
        n = len(nums)
        if n < 2:
            return 0

        left,right = float('inf'),float('-inf')
        flag = False
        # 寻找非上升子序列的最小元素
        for i in range(n-1):
            if nums[i]>nums[i+1]:
                flag = True
            if flag:
                left = min(left, nums[i+1])
        flag = False

        # 非上升子序列的最大元素
        for i in reversed(range(n-1)):
            if nums[i] > nums[i+1]:
                flag = True
            if flag:
                right = max(right, nums[i])
        left_index = right_index = 0
        for i in range(n):
        # 第一个大于left的元素
            if nums[i] > left:
                left_index = i
                break
        for i in reversed(range(n)):
        # 第一个啸宇right的元素
            if nums[i] < right:
                right_index = i
                break
    #     print(left, left_index, right,right_index)
        return 0 if right_index == left_index else right_index - left_index + 1
        
```
### 题目：
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```
示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
```

### 解析1：
递归，对树的每个结点进行递归求解。判断t1，t2是否为空，返回不为空的一个，如果都为空就返回空。然后根节点相加，再对左子树和右子树递归调用。

N:结点的总数目
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|56 ms|100%|
|空间|$O(1)$|12.8 MB|6.09%|

步骤：
1. 判断根节点是否为空，返回不为空的根节点；
2. 统一都加在t1树上面，最后返回t1树；
3. 根节点值相加；
4. 对左子树和右子树分别递归调用函数；


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def mergeTrees(self, t1, t2):
        if not t1:
            return t2
        if not t2:
            return t1

        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        
        return t1
```
### 题目：
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

```
示例 1:

输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".
```
### 解析1：
暴力法：生成每一个子串，然后判断是否是回文的，如果是回文的就加1.

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^3)$|1488 ms|5.20%|
|空间|$O(1)$|11.8 MB|59.09%|

```python
class Solution(object):
    def countSubstrings(self, s):
        n = len(s)
        res = 0
        for i in range(n):
            for j in range(i, n):
                temp_str = s[i:j+1]
                if self.IsPalin(temp_str):
                    res += 1
        return res
    
    def IsPalin(self, temp_str):
    # 判断一个字符串是否是回文
        return temp_str == temp_str[::-1]
```

### 解析2：
中心扩散法，遍历每一个字符，以当前字符为回文子串的中心来进行扩散，产生一个新的回文子串就res++。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|116 ms|80.26%|
|空间|$O(1)$|11.6 MB|64.77%|

步骤：
1. 遍历每一个字符；
   1. 以当前字符i为中心，进行扩散，奇数扩散，直到不满足条件；
   2. 以i,i+1为中心，进行扩散，偶数扩散；

```python
class Solution(object):
    def countSubstrings(self, s):
        res,n = 0,len(s)
        
        for i in range(n):
            res += self.helper(s, i, i)
            res += self.helper(s, i, i+1)
        return res
    
    def helper(self,s, left, right):
        res = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            res += 1
            left -= 1
            right += 1
        return res
```
### 题目：
给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

```
示例 ：

输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
```

### 解析1：
直接递归调用，每次提取当前数组的最大元素，然后获取其索引，对最大元素左边的和右边的分别递归调用函数。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|372 ms|19.85%|
|空间|$O(n)$|14 MB|5.00%|

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
            
        maxnum = max(nums)
        maxindex = nums.index(maxnum)
        
        root = TreeNode(maxnum)

        root.left = self.constructMaximumBinaryTree(nums[:maxindex])
        root.right = self.constructMaximumBinaryTree(nums[maxindex+1:])
        return root
```
通过此方法，可以类似构建一个二叉查找树，构建左子树的时候，对小于根节点的数进行调用，反之对大于根节点的数进行递归调用。

### 题目：
几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

```
例 1：

输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).
```

### 解析1：
暴力法：获取表格的左右元素，然后排序，排序后返回第k个。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$| ||
|空间|$O(mn)$| 超内存||

```python
class Solution(object):
    def findKthNumber(self, m, n, k):
        table = [i*j for i in range(1, m+1) for j in range(1, n+1)]
        table.sort()
        return table[k-1]
```

### 解析2：
二分查找。遍历1到mn，如果有k个数小于这个数。
```python
class Solution(object):
    def findKthNumber(self, m, n, k):
        def enough(x):
            count = 0
            for i in xrange(1, m+1):
                count += min(x // i, n)
            return count >= k

        lo, hi = 1, m * n
        while lo < hi:
            mi = (lo + hi) / 2
            if not enough(mi):
                lo = mi + 1
            else:
                hi = mi
        return lo
```

参考资料：http://www.mamicode.com/info-detail-2445751.html
### 题目：
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```
示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

### 解析1：
直接二分查找，没啥好说的。

```python
class Solution(object):
    def search(self, nums, target):
        n = len(nums)
        left, right = 0,n-1
        while left <= right:
            mid = (left + right)//2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid-1
            elif nums[mid] < target:
                left = mid + 1
        return -1
```

关于二分查找一个很好的总结：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/；
https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/；
### 题目：
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

```
示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
注意:

0 < prices.length <= 50000.
0 < prices[i] < 50000.
0 <= fee < 50000.
```

### 解析1：
和122题类似，只是每次交易的时候需要考虑交易费，当卖出股票的时候减去交易费。不能再像122题那样使用贪心算法求解，因为有fee来控制，如果fee比较大，影响偏向于交易次数少的方案。

**状态转移方程：**
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
dp0 = max(dp0, dp1+prices[i]-fee)  
第i天未持有股票获得的最多利润 = max(第i-1天未持有股票获得的最多利润， 第i-1天持有股票获得的最多利润 卖掉 prices[i])

dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
dp1 = max(dp1, dp0-prices[0])
第i天持有股票获得的最多利润 = max(第i-1天持有股票获得的最多利润， 第i-1天未持有股票获得的最多利润 买入 prices[i])
```

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|860 ms|70.9%|
|空间|$O(1)$|17.7 MB|12.82%|


```python
class Solution(object):
    def maxProfit(self, prices, fee):
        if not prices:
            return 0
        dp0,dp1 = 0, -prices[0]
        
        length = len(prices)
        for i in range(1, length):
            temp = dp0
            dp0 = max(dp0, dp1 + prices[i] - fee)
            dp1 = max(dp1, temp - prices[i])
        return dp0
```
### 题目：
根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

### 解析1：
两次遍历数组，然后判断后面最近的大于当前数的索引，注意如果不存在返回0，最后要加一个判断。暴力法，超时。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n^2)$|超时||
|空间|$O(n)$|||

```python
class Solution(object):
    def dailyTemperatures(self, T):

        res = []
        n = len(T)
        for i in range(n-1):
            temp  = 1
            for j in range(i+1, n):
                if T[i] < T[j]:
                    break
                else:
                    temp += 1
                if j == n-1 and T[j] <= T[i]:
                    temp = 0
            res.append(temp)

        return res + [0]
```

### 解析2：
用一个栈保存温度的索引，如果当前元素大于栈顶元素的温度，那么当前元素是栈顶元素对应的下一个上升温度。如果不大于，就将其入栈，直到找到大于栈顶的元素。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|520ms|87.89%|
|空间|$O(n)$|15MB|38.89%|


步骤：
1. 建立一个站；
2. 遍历温度数组；
   1. 如果stack不为空，并且栈顶元素温度小于当前的遍历元素值，则出栈，此时索引距离差即天数差；
   2. 否则入栈

```python
class Solution(object):
    def dailyTemperatures(self, T):
        stack,res = [],[0]*len(T)
        for i,v in enumerate(T):
            while stack and T[stack[-1]] < v:
                res[stack.pop()] = i - stack[-1]
            stack.append(i)
        return res
```


### 题目：
数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
```
示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```

### 解析1：
动态规划，关键依然是如何建立状态转移方程。   
 
状态含义：dp[i]到达第n台阶所需要的最小花费；   
状态转移方程：dp[i] = min(dp[i-1],dp[i-2]) + cost[i]；   
到达第i个台阶，有两种方式，前一个或者前两个台阶跳过去，比较其大小，然后加cost[i]。  
到达楼顶有两种方式，跳到第n台阶，或者第n-1个台阶，所以最后要输出min(dp[n-1],dp[n-2])  

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|760 ms|10.75%|
|空间|$O(1)$|19 MB|50.62%|

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        
        if n == 0:
            return 0
        elif n == 1:
            return cost[0]

        dp = [0]*(n)
        dp[0] = cost[0]
        dp[1] = cost[1]
        
        for i in range(2, n):
            dp[i] = min(dp[i-1],dp[i-2]) + cost[i]
        return min(dp[n-1],dp[n-2])
```
### 题目：
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 
```
示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
```

### 解析1：
双指针，快慢指针。快指针一次走两步，满指针

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|24 ms|50.34%|
|空间|$O(n)$|11.8 MB|33.78%|

```python
class Solution(object):
    def middleNode(self, head):
        fast = head
        slow = head
        
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```
### 题目；
在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
示例 2：

输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
```
### 解析1：
* **算法流程：**
  * 1.将新鲜和腐烂的分开放在两个set中；
  * 2.对腐烂的进行遍历，将他的相邻位置全部变成腐烂的；
  * 3.更新腐烂的集合为新腐烂的橘子，同时新鲜的减去腐烂的这些；
  * 4.如果新腐烂的在fresh之前变成空集，则返回-1；


* **复杂度：**

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(mn)$|60 ms|57.90%|
|空间|$O(mn)$|13.1 MB|17.65%|

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        m,n = len(grid),len(grid[0])
        
        fresh = {(i,j) for i in range(m) for j in range(n) if grid[i][j]==1}
        rotten = {(i,j) for i in range(m) for j in range(n) if grid[i][j]==2}
        time = 0

        while fresh:
            if not rotten:return -1
            rotten = {(i+dx,j+dy) for i,j in rotten for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)] if (i+dx,j+dy) in fresh} # 一轮后新的rotten，更新才可以
            fresh -= rotten
            time += 1  # 多个腐烂的同时开始像两遍腐烂

        return time
```
### 题目：
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

```
示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

### 解析1：
栈依次保存每一个字符，如果新元素和栈顶元素相同，那么pop，否则继续添加。

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|80 ms|93.76%|
|空间|$O(1)$|14 MB |100%|

```python
class Solution:
    def removeDuplicates(self, S: str) -> str:
        stack = []
        for c in S:
            if not stack or stack[-1] != c:
                stack.append(c)
            else:
                stack.pop()
        return ''.join(stack)
```
### 题目：
排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。
```
示例 1：

输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
```

### 解析1：
遍历每一个位置，更新索引，更新新加入的值。初始化数组为0。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(max(G,N))$|72 ms|12.90%|
|空间|$O(1)$|13.6 MB|23.65%|
这个复杂度牛逼。

```python
class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        res = [0]*num_people
        temp = 1
        idx = 0
        while candies:
            if idx>=num_people:idx %= num_people
            if candies < temp:
                res[idx] += candies
                break
            res[idx] += temp
            candies -= temp
            idx += 1
            temp += 1
        return res
```

思路一样，代码进行了优化。看起来更加的简介，复杂度并没有降低。

```python
class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        ans = [0] * num_people
        i = 0
        while candies != 0:
            ans[i % num_people] += min(i + 1, candies)
            candies -= min(i + 1, candies)
            i += 1
        return ans
```
### 题目：
```
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

推荐解析3.
### 解析1： 
两个for循环，并不是明智的做法。  
时间复杂度$O(n^2)$  
空间复杂度：$O(1)$  

```python
def twoSum(self, nums, target):
    if len(nums) < 2:
        return []
    for i in range(len(nums)-1):
        for j in range(i+1,len(nums)):
            if nums[i] + nums[j] == target:
                return [i,j]
```

### 解析2： 
通过哈希表保存数值，然后实现查找时间为$O(1)$。需要遍历两次数据，一次建立哈希表，一次判断是否在哈希表里面。保存在字典里面。

步骤：
1. 遍历数组，将数组保存在字典中，key为数组值，value为索引；
2. 再次遍历数组，判断差是否在字典里面，并且保证索引不同；

|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|76 ms|71.50%|
|空间|$O(n)$|15.4 MB|5.05%|

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_dict = {}
        n = len(nums)
        res = []
        for i in range(n):
            num_dict[nums[i]] = i
        for i in range(n):
            temp = target - nums[i]
            if temp in num_dict and i != num_dict[temp]:
                return [i,num_dict[temp]]
```

### 解析3：
* **算法流程：**
  * 1. 建立一个字典数，key为数组值，value为index索引；
  * 2. 遍历数组，如果数不在字典中，便加入进去；
  * 3. 如果差在字典里面，并且索引不同，则返回[i.j];

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|89.93%|
|空间|$O(n)$|14.5 MB|44.25%|


```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        if n < 2:return []
        res = []
        num_dict = dict()
        for i in range(n):
            if nums[i] not in num_dict:
                num_dict[nums[i]] = i
            if target-nums[i] in num_dict and num_dict[target-nums[i]]!=i:
                return [i, num_dict[target-nums[i]]]
```

### 题目：
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

### 解析1：
模拟两个数相加的过程，依次向前进位，注意哑结点，链表为空等现象。

* **算法流程：**
1. 设置哑结点，re，r，进位初始化为0；
2. 遍历l1和l2两个链表直到他们尾端；
   1. 用x,y分别表示l1，l2结点的值，如果到达尾部，则值为0；
   2. 进行相加，s = carry + x+y，更新carry，保存s；
   3. l1，l2前进到下一个结点；
3. 判断carry是否>0，下一位保留一个进位；
4. 返回哑结点的下一个结点。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|
|时间|$O(n)$|52 ms|89.93%|
|空间|$O(n)$|14.5 MB|44.25%|

```python
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        re = ListNode(0)
        r=re
        carry=0
        
        while(l1 or l2):
            x= l1.val if l1 else 0
            y= l2.val if l2 else 0
            
            s=carry+x+y
            carry=s//10
            
            r.next=ListNode(s%10)
            r=r.next
            
            if(l1!=None):l1=l1.next
            if(l2!=None):l2=l2.next
                
        if(carry>0):
            r.next=ListNode(1)
        return re.next
```

### 解析2：
一个较快的方法，思路基本一样，实现的方案不太一样。

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        
        n = l1.val + l2.val
        l3 = ListNode(n % 10)
        l3.next = ListNode(n // 10)
        p1 = l1.next
        p2 = l2.next
        p3 = l3
        while True:
            if p1 and p2:
                sum = p1.val + p2.val + p3.next.val
                p3.next.val = sum % 10
                p3.next.next = ListNode(sum // 10)
                p1 = p1.next
                p2 = p2.next
                p3 = p3.next
            elif p1 and not p2:
                sum = p1.val + p3.next.val
                p3.next.val = sum % 10
                p3.next.next = ListNode(sum // 10)
                p1 = p1.next
                p3 = p3.next
            elif not p1 and p2:
                sum = p2.val + p3.next.val
                p3.next.val = sum % 10
                p3.next.next = ListNode(sum // 10)
                p2 = p2.next
                p3 = p3.next
            else:
                if p3.next.val == 0:
                    p3.next = None
                break
        return l3
```



### 题目：
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

>示例 1:
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

推荐解析3.
### 解析1：
暴力法，遍历所有的子字符串，然后判断子字符串是否含有重复字符，求不含重复子字符串的最大长度。超时。

时间：O(n^3)
空间：O(1)

```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        res = 0
        for i in range(len(s)):
            for j in range(i+1, len(s)+1):
                temp = s[i:j]
                if len(list(set(temp))) == len(temp):
                    res = max(res, len(temp))
        return res
```
### 解析2：
滑动窗口，不断滑动窗口，用一个哈希表保存窗口内的元素，同时保存字符串的起始位置。如果新字符不在哈希表里面添加新元素，依次从左边去掉元素，直到哈希表中不存在新元素为止，left不断左移。

时间：O(n)
空间：O(n)

步骤：
1. 初始化字符串滑窗哈希表lookup，起点和终点；
2. 循环，直到start or end 大于等于length；
3. 如果字符在lookup里面，去掉最左边的元素，起点+1，更新最大长度；
4. 如果不在lookup，添加新元素，end+1；
5. 返回max(res, length-start)，后面如果不出现重复字符，maxlen不会更新。


```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s:
            return 0
        lookup = set()
        length = len(s)
        res,start,end = 0,0,0
        
        while start < length and end < length:
            if s[end] in lookup:
                lookup.remove(s[start])
                res = max(res, end-start)
                start += 1
                
            else:
                lookup.add(s[end])
                end += 1
        return max(res, length-start)
```

### 解析3：
滑动窗口，建立一个字典保存每一个元素的位置，如果新字符在字典中出现过，则出现了重复，求前面字符串的长度，更新start值。前面出现重复字符的值索引大于start才是有效重复字符。

* **复杂度：**
|  |复杂度|大小|百分比|
|--|--|--|--|   
|时间|$O(n)$|52 ms|81.39%|
|空间|$O(1)$|12.6 MB|23.34%|

* **算法流程：**

1. 建立一个字典保存每个字符的出现位置，字符串起始值，最大字符串长度；
2. 遍历字符串：
   1. 如果字符在字典里面，并且之前出现的字符位置在大于等于start；
   2. 更新start值和最大字符串长度值，start值从开始重复的下一个元素开始算起；
   3. 更新字典中字符的位置索引
3. 注意最后的返回值

滑动窗口如何滑，从头开始，窗口的end不断右移，直到新元素在窗口中出现过，视为当前最长的无重复子串。然后更新窗口的start到新元素之前所在位置的下一个元素。

```python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        res = 0
        index_dict = {}
        n = len(s)
        start = 0
            
        for i in range(n):
            # 如果s[i]在index_dict里面，并且所在元素索引大于start
            if s[i] in index_dict and index_dict[s[i]]>=start:
                res = max(res, i-start)
                start = index_dict[s[i]]+1
            index_dict[s[i]] = i
        return max(res, n-start)   # 可能会一直碰不到重复的
```
更多的解法参照：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/
